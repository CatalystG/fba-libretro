Index: compile_libretro.sh
===================================================================
--- compile_libretro.sh	(revision 847)
+++ compile_libretro.sh	(working copy)
@@ -1,108 +0,0 @@
-#!/bin/sh
-
-FORMAT=libretro
-
-#******************
-# PROGRAM FUNCTIONS
-#******************
-
-clean()
-{
-   cd src-0.2.97.26/
-	make -f makefile.libretro clean
-}
-
-make_libretro()
-{
-   cd src-0.2.97.26/
-   make -f makefile.libretro generate
-	make -f makefile.libretro -j4
-}
-
-make_debug()
-{
-   cd src-0.2.97.26/
-   make -f makefile.libretro generate
-	make -f makefile.libretro -j4 DEBUG=1
-}
-
-#******************
-# DISPLAY FUNCTIONS
-#******************
-
-title()
-{
-	echo ""
-	echo "***********************"
-	echo "COMPILER SCRIPT FOR $FORMAT"
-	echo "***********************"
-}
-
-display_clean()
-{
-	echo "clean          Clean the object files"
-}
-
-display_make()
-{
-	echo "make           Compile libretro library"
-}
-
-display_make_debug()
-{
-	echo "make_debug     Compile DEBUG libretro library"
-}
-
-display_all_options()
-{
-	display_clean
-	display_make
-	display_make_debug
-}
-
-display_usage()
-{
-	echo "Usage: compile_libretro.sh [options]"
-	echo "Options:"
-	display_all_options
-}
-
-#***********************
-# MAIN CONTROL FLOW LOOP
-#***********************
-
-title
-if [ ! -n "$1" ]; then
-	display_usage
-else
-	for i in "$@"
-	do
-		if [ "$i" = "help" ]; then
-			display_usage
-		fi
-		if [ "$i" = "clean" ]; then
-			echo ""
-			echo "*************************************"
-			echo "DOING:"
-			display_clean
-			echo "*************************************"
-			clean
-		fi
-		if [ "$i" = "make" ]; then
-			echo ""
-			echo "*************************************"
-			echo "DOING:"
-			display_make
-			echo "*************************************"
-			make_libretro
-		fi
-		if [ "$i" = "make_debug" ]; then
-			echo ""
-			echo "*************************************"
-			echo "DOING:"
-			display_make
-			echo "*************************************"
-			make_debug
-		fi
-	done
-fi
Index: generate_files.sh
===================================================================
--- generate_files.sh	(revision 847)
+++ generate_files.sh	(working copy)
@@ -1,59 +0,0 @@
-#!/bin/bash
-
-if [ -f src/dep/generated/driverlist.h ]; then
-   rm -rf src/dep/generated
-fi
-
-if [ -d src/dep/generated ]; then
-   echo 'Directory 'src/dep/generated' already exists, skipping creation...'
-else
-   mkdir src/dep/generated
-fi
-
-#generate gamelist.txt and src/dep/generated/driverlist.h
-perl src/dep/scripts/gamelist.pl -o src/dep/generated/driverlist.h -l gamelist.txt \
-src/burn/drv/capcom \
-src/burn/drv/cave \
-src/burn/drv/cps3 \
-src/burn/drv/dataeast \
-src/burn/drv/galaxian \
-src/burn/drv/irem \
-src/burn/drv/konami \
-src/burn/drv/megadrive \
-src/burn/drv/neogeo \
-src/burn/drv/pce \
-src/burn/drv/pgm \
-src/burn/drv/pre90s \
-src/burn/drv/psikyo \
-src/burn/drv/pst90s \
-src/burn/drv/sega \
-src/burn/drv/snes \
-src/burn/drv/taito \
-src/burn/drv/toaplan
-
-#generate src/dep/generated/neo_sprite_func.h and src/dep/generated/neo_sprite_func_table.h
-perl src/dep/scripts/neo_sprite_func.pl -o src/dep/generated/neo_sprite_func.h
-
-#generate src/dep/generated/psikyo_tile_func.h and src/dep/generated/psikyo_tile_func_table.h
-perl src/dep/scripts/psikyo_tile_func.pl -o src/dep/generated/psikyo_tile_func.h
-
-#generate src/dep/generated/cave_sprite_func.h and src/dep/generated/cave_sprite_func_table.h
-perl src/dep/scripts/cave_sprite_func.pl -o src/dep/generated/cave_sprite_func.h
-
-#generate src/dep/generated/cave_tile_func.h and src/dep/generated/cave_tile_func_table.h
-perl src/dep/scripts/cave_tile_func.pl -o src/dep/generated/cave_tile_func.h
-
-#generate src/dep/generated/toa_gp9001_func.h and src/dep/generated/toa_gp9001_func_table.h
-perl src/dep/scripts/toa_gp9001_func.pl -o src/dep/generated/toa_gp9001_func.h
-
-g++ -o pgm_sprite_create src/burn/drv/pgm/pgm_sprite_create.cpp
-./pgm_sprite_create > src/dep/generated/pgm_sprite.h
-
-#compile m68kmakeecho 
-gcc -o m68kmake src/cpu/m68k/m68kmake.c
-
-#create m68kops.h with m68kmake
-./m68kmake src/cpu/m68k/ src/cpu/m68k/m68k_in.c
-
-g++ -o  ctvmake src/burn/drv/capcom/ctv_make.cpp
-./ctvmake > src/dep/generated/ctv.h
Index: makefile.libretro
===================================================================
--- makefile.libretro	(revision 847)
+++ makefile.libretro	(working copy)
@@ -1,5 +1,6 @@
 DEBUG = 0
-LIBRETRO_OPTIMIZATIONS = 0
+LIBRETRO_OPTIMIZATIONS = 1
+FRONTEND_SUPPORTS_RGB565 = 1
 
 ifeq ($(platform),)
 platform = unix
@@ -12,6 +13,18 @@
 endif
 endif
 
+# system platform
+system_platform = unix
+ifeq ($(shell uname -a),)
+   system_platform = win
+EXE_EXT=.exe
+else ifneq ($(findstring Darwin,$(shell uname -a)),)
+   system_platform = osx
+else ifneq ($(findstring MINGW,$(shell uname -a)),)
+   system_platform = win
+endif
+
+
 MAIN_FBA_DIR := src
 FBA_BURN_DIR := $(MAIN_FBA_DIR)/burn
 FBA_BURN_DRIVERS_DIR := $(MAIN_FBA_DIR)/burn/drv
@@ -20,6 +33,8 @@
 FBA_CPU_DIR := $(MAIN_FBA_DIR)/cpu
 FBA_LIB_DIR := $(MAIN_FBA_DIR)/dep/libs
 FBA_INTERFACE_DIR := $(MAIN_FBA_DIR)/intf
+FBA_GENERATED_DIR = $(MAIN_FBA_DIR)/dep/generated
+FBA_SCRIPTS_DIR = $(MAIN_FBA_DIR)/dep/scripts
 
 EXTERNAL_ZLIB = 0
 
@@ -34,33 +49,49 @@
    SHARED := -dynamiclib
    ENDIANNESS_DEFINES := -DLSB_FIRST
 else ifeq ($(platform), ps3)
-   TARGET := libretro.a
+   TARGET := libretro_ps3.a
    CC = $(CELL_SDK)/host-win32/ppu/bin/ppu-lv2-gcc.exe
    CXX = $(CELL_SDK)/host-win32/ppu/bin/ppu-lv2-g++.exe
    AR = $(CELL_SDK)/host-win32/ppu/bin/ppu-lv2-ar.exe
    ENDIANNESS_DEFINES =  -DWORDS_BIGENDIAN
-   PLATFORM_DEFINES := -D__CELLOS_LV2
+   PLATFORM_DEFINES += -D__CELLOS_LV2__
    EXTERNAL_ZLIB = 1
 else ifeq ($(platform), sncps3)
-   TARGET := libretro.a
+   TARGET := libretro_ps3.a
    CXX	= $(CELL_SDK)/host-win32/sn/bin/ps3ppusnc.exe
    CC = $(CELL_SDK)/host-win32/sn/bin/ps3ppusnc.exe
    AR = $(CELL_SDK)/host-win32/sn/bin/ps3snarl.exe
    ENDIANNESS_DEFINES =  -DWORDS_BIGENDIAN
    PLATFORM_DEFINES += -D__CELLOS_LV2__ -DSN_TARGET_PS3
    EXTERNAL_ZLIB = 1
+else ifeq ($(platform), psl1ght)
+   TARGET := libretro_psl1ght.a
+   CC = $(PS3DEV)/ppu/bin/ppu-gcc$(EXE_EXT)
+   CXX = $(PS3DEV)/ppu/bin/ppu-g++$(EXE_EXT)
+   AR = $(PS3DEV)/ppu/bin/ppu-ar$(EXE_EXT)
+   ENDIANNESS_DEFINES =  -DWORDS_BIGENDIAN
+   PLATFORM_DEFINES += -D__CELLOS_LV2__
+   EXTERNAL_ZLIB = 1
 else ifeq ($(platform), xenon)
-   TARGET := libretro.a
-   CC = xenon-gcc
-   CXX = xenon-g++
-   AR = xenon-ar
+   TARGET := libretro_xenon360.a
+   CC = xenon-gcc$(EXE_EXT)
+   CXX = xenon-g++$(EXE_EXT)
+   AR = xenon-ar$(EXE_EXT)
    ENDIANNESS_DEFINES = -DWORDS_BIGENDIAN
    PLATFORM_DEFINES := -D__LIBXENON__ -m32 -D__ppc__
+else ifeq ($(platform), ngc)
+   TARGET := libretro_ngc.a
+   CC = $(DEVKITPPC)/bin/powerpc-eabi-gcc$(EXE_EXT)
+   CXX = $(DEVKITPPC)/bin/powerpc-eabi-g++$(EXE_EXT)
+   AR = $(DEVKITPPC)/bin/powerpc-eabi-ar$(EXE_EXT)
+   ENDIANNESS_DEFINES = -DWORDS_BIGENDIAN
+   PLATFORM_DEFINES := -DGEKKO -DHW_DOL -mrvl -mcpu=750 -meabi -mhard-float
+   EXTERNAL_ZLIB = 1
 else ifeq ($(platform), wii)
-   TARGET := libretro.a
-   CC = $(DEVKITPPC)/bin/powerpc-eabi-gcc
-   CXX = $(DEVKITPPC)/bin/powerpc-eabi-g++
-   AR = $(DEVKITPPC)/bin/powerpc-eabi-ar
+   TARGET := libretro_wii.a
+   CC = $(DEVKITPPC)/bin/powerpc-eabi-gcc$(EXE_EXT)
+   CXX = $(DEVKITPPC)/bin/powerpc-eabi-g++$(EXE_EXT)
+   AR = $(DEVKITPPC)/bin/powerpc-eabi-ar$(EXE_EXT)
    ENDIANNESS_DEFINES = -DWORDS_BIGENDIAN
    PLATFORM_DEFINES := -DGEKKO -DHW_RVL -mrvl -mcpu=750 -meabi -mhard-float
    EXTERNAL_ZLIB = 1
@@ -73,8 +104,11 @@
    ENDIANNESS_DEFINES := -DLSB_FIRST
 endif
 
-.PHONY: clean generate-files
+CC_SYSTEM = gcc
+CXX_SYSTEM = g++
 
+.PHONY: clean generate-files generate-files-clean clean-objs
+
 all: $(TARGET)
 
 BURN_BLACKLIST := $(FBA_BURNER_DIR)/un7z.cpp \
@@ -114,9 +148,9 @@
 	$(FBA_CPU_DIR)/nec/necinstr.c \
 	$(FBA_BURN_DIR)/drv/capcom/ctv_make.cpp
 
-ifeq ($(LIBRETRO_OPTIMIZATIONS), 1)
-BURN_BLACKLIST += $(FBA_BURN_DIR)/drv/capcom/ctv.cpp
-endif
+#ifeq ($(LIBRETRO_OPTIMIZATIONS), 1)
+#BURN_BLACKLIST += $(FBA_BURN_DIR)/drv/capcom/ctv.cpp
+#endif
 
 ifeq ($(EXTERNAL_ZLIB), 1)
 BURN_BLACKLIST += $(FBA_BURNER_DIR)/unzip.c \
@@ -192,7 +226,6 @@
 	-I$(LIBRETRO_DIR) \
 	-I$(LIBRETRO_DIR)/tchar \
 	-I$(FBA_BURN_DIR) \
-	-I$(FBA_BURN_DIR)/burner \
 	-I$(MAIN_FBA_DIR)/cpu \
 	-I$(FBA_BURN_DIR)/snd \
 	-I$(FBA_BURN_DIR)/devices \
@@ -200,23 +233,8 @@
 	-I$(FBA_INTERFACE_DIR)/input \
 	-I$(FBA_INTERFACE_DIR)/cd \
 	-I$(FBA_BURNER_DIR) \
-	-I$(MAIN_FBA_DIR)/dep/generated \
 	-I$(FBA_CPU_DIR) \
-	-I$(FBA_CPU_DIR)/m6809 \
-	-I$(FBA_CPU_DIR)/m6805 \
-	-I$(FBA_CPU_DIR)/m6800 \
-	-I$(FBA_CPU_DIR)/h6280 \
-	-I$(FBA_CPU_DIR)/nec \
-	-I$(FBA_CPU_DIR)/hd6309 \
-	-I$(FBA_CPU_DIR)/arm7 \
 	-I$(FBA_CPU_DIR)/i8039 \
-	-I$(FBA_CPU_DIR)/konami \
-	-I$(FBA_CPU_DIR)/m68k \
-	-I$(FBA_CPU_DIR)/m6502 \
-	-I$(FBA_CPU_DIR)/z80 \
-	-I$(FBA_CPU_DIR)/sh2 \
-	-I$(FBA_CPU_DIR)/s2650 \
-	-I$(FBA_CPU_DIR)/arm \
 	-I$(FBA_LIB_DIR)/zlib \
 	-I$(FBA_BURN_DIR)/drv/capcom \
 	-I$(FBA_BURN_DIR)/drv/dataeast \
@@ -226,11 +244,11 @@
 	-I$(FBA_BURN_DIR)/drv/sega \
 	-I$(FBA_BURN_DIR)/drv/toaplan \
 	-I$(FBA_BURN_DIR)/drv/taito \
+	-I$(FBA_GENERATED_DIR) \
 	-I$(FBA_LIB_DIR)
 
 ifeq ($(LIBRETRO_OPTIMIZATIONS), 1)
 FBA_DEFINES += -D__LIBRETRO_OPTIMIZATIONS__ 
-INCDIRS += -I$(MAIN_FBA_DIR)/dep/generated-libretro
 endif
 
 ifeq ($(DEBUG), 1)
@@ -252,23 +270,87 @@
 CXXFLAGS += $(fpic) $(WARNINGS_DEFINES) $(FBA_DEFINES)
 LDFLAGS += $(fpic)
 
+ifeq ($(FRONTEND_SUPPORTS_RGB565), 1)
+CFLAGS += -DFRONTEND_SUPPORTS_RGB565
+CXXFLAGS += -DFRONTEND_SUPPORTS_RGB565
+endif
 
 ifeq ($(ZLIB_INTERNAL), 0)
 INCDIRS += -I$(FBA_LIB_DIR)
 endif
 
-generate:
-	rm -rf src/dep/generated
-	sh ./generate_files.sh
+ifeq ($(LIBRETRO_OPTIMIZATIONS), 1)
+GENERATE_OPTS := -D__LIBRETRO_OPTIMIZATIONS__
+else
+GENERATE_OPTS :=
+endif
 
-$(TARGET): generate-files $(OBJS)
+PERL = perl$(EXE_EXT)
+M68KMAKE_EXE = m68kmake$(EXE_EXT)
+CTVMAKE_EXE = ctvmake$(EXE_EXT)
+PGM_SPRITE_CREATE_EXE = pgmspritecreate$(EXE_EXT)
+EXE_PREFIX = ./
+
+generate-files-clean:
+	rm -rf $(FBA_GENERATED_DIR)/
+	rm -rf $(FBA_CPU_DIR)/m68k/m68kopac.c
+	rm -rf $(FBA_CPU_DIR)/m68k/m68kopdm.c
+	rm -rf $(FBA_CPU_DIR)/m68k/m68kopnz.c
+	rm -rf $(FBA_CPU_DIR)/m68k/m68kops.c
+	rm -rf $(FBA_CPU_DIR)/m68k/m68kops.h
+
+generate-files:
+	@mkdir -p $(FBA_GENERATED_DIR) 2>/dev/null || /bin/true
+	@echo "Generating $(FBA_GENERATED_DIR)/driverlist.h..."
+	@echo ""
+	$(PERL) $(FBA_SCRIPTS_DIR)/gamelist.pl -o $(FBA_GENERATED_DIR)/driverlist.h -l gamelist.txt $(FBA_BURN_DRIVERS_DIR)/capcom $(FBA_BURN_DRIVERS_DIR)/cave $(FBA_BURN_DRIVERS_DIR)/cps3 $(FBA_BURN_DRIVERS_DIR)/dataeast $(FBA_BURN_DRIVERS_DIR)/galaxian $(FBA_BURN_DRIVERS_DIR)/irem $(FBA_BURN_DRIVERS_DIR)/konami $(FBA_BURN_DRIVERS_DIR)/megadrive $(FBA_BURN_DRIVERS_DIR)/neogeo $(FBA_BURN_DRIVERS_DIR)/pce $(FBA_BURN_DRIVERS_DIR)/pgm $(FBA_BURN_DRIVERS_DIR)/pre90s $(FBA_BURN_DRIVERS_DIR)/psikyo $(FBA_BURN_DRIVERS_DIR)/pst90s $(FBA_BURN_DRIVERS_DIR)/sega $(FBA_BURN_DRIVERS_DIR)/snes $(FBA_BURN_DRIVERS_DIR)/taito $(FBA_BURN_DRIVERS_DIR)/toaplan
+	@echo ""
+	@echo "Generating $(FBA_GENERATED_DIR)/neo_sprite_func.h..."
+	@echo ""
+	@echo "Generating $(FBA_GENERATED_DIR)/neo_sprite_func_table.h..."
+	@echo ""
+	$(PERL) $(FBA_SCRIPTS_DIR)/neo_sprite_func.pl -o $(FBA_GENERATED_DIR)/neo_sprite_func.h $(LIBRETRO_OPTIMIZATIONS)
+	@echo ""
+	@echo "Generating $(FBA_GENERATED_DIR)/psikyo_tile_func.h..."
+	@echo ""
+	@echo "Generating $(FBA_GENERATED_DIR)/psikyo_tile_func_table.h..."
+	@echo ""
+	$(PERL) $(FBA_SCRIPTS_DIR)/psikyo_tile_func.pl -o $(FBA_GENERATED_DIR)/psikyo_tile_func.h
+	@echo "Generating $(FBA_GENERATED_DIR)/cave_sprite_func.h..."
+	@echo ""
+	@echo "Generating[ $(FBA_GENERATED_DIR)/cave_tile_func_table.h"
+	@echo ""
+	$(PERL) $(FBA_SCRIPTS_DIR)/cave_sprite_func.pl -o $(FBA_GENERATED_DIR)/cave_sprite_func.h
+	$(PERL) $(FBA_SCRIPTS_DIR)/cave_tile_func.pl -o $(FBA_GENERATED_DIR)/cave_tile_func.h
+	@echo ""
+	@echo "Generate $(FBA_GENERATED_DIR)/toa_gp9001_func_table.h"
+	@echo ""
+	$(PERL) $(FBA_SCRIPTS_DIR)/toa_gp9001_func.pl -o $(FBA_GENERATED_DIR)/toa_gp9001_func.h
+	$(CXX_SYSTEM) $(GENERATE_OPTS) -o $(PGM_SPRITE_CREATE_EXE) $(FBA_BURN_DRIVERS_DIR)/pgm/pgm_sprite_create.cpp
+	@echo ""
+	@echo "Generating $(FBA_GENERATED_DIR)/pgm_sprite.h..."
+	@echo ""
+	$(EXE_PREFIX)$(PGM_SPRITE_CREATE_EXE) > $(FBA_GENERATED_DIR)/pgm_sprite.h
+	$(CC_SYSTEM) $(GENERATE_OPTS) -o $(M68KMAKE_EXE) $(FBA_CPU_DIR)/m68k/m68kmake.c
+	$(EXE_PREFIX)$(M68KMAKE_EXE) $(FBA_CPU_DIR)/m68k/ $(FBA_CPU_DIR)/m68k/m68k_in.c
+	$(CXX_SYSTEM) $(GENERATE_OPTS) -o $(CTVMAKE_EXE) $(FBA_BURN_DRIVERS_DIR)/capcom/ctv_make.cpp
+	@echo ""
+	@echo "Generating $(FBA_GENERATED_DIR)/ctv.h..."
+	@echo ""
+	$(EXE_PREFIX)$(CTVMAKE_EXE) > $(FBA_GENERATED_DIR)/ctv.h
+
+$(TARGET): $(OBJS)
 	@echo "LD $@"
 ifeq ($(platform), ps3)
 	@$(AR) rcs $@ $(OBJS)
 else ifeq ($(platform), sncps3)
 	$(AR) rcs $@ $(OBJS)
+else ifeq ($(platform), psl1ght)
+	$(AR) rcs $@ $(OBJS)
 else ifeq ($(platform), xenon)
 	@$(AR) rcs $@ $(OBJS)
+else ifeq ($(platform), ngc)
+	@$(AR) rcs $@ $(OBJS)
 else ifeq ($(platform), wii)
 	@$(AR) rcs $@ $(OBJS)
 else
@@ -283,9 +365,12 @@
 	@echo "CC $<"
 	@$(CC) -c -o $@ $< $(CFLAGS) $(INCDIRS)
 
+clean-objs:
+	rm -f $(OBJS)
+
 clean:
 	rm -f $(TARGET)
 	rm -f $(OBJS)
-ifeq ($(GENERATE_FILES), 1)
-	rm -rf src/dep/generated
-endif
+	rm -f $(M68KMAKE_EXE)
+	rm -f $(PGM_SPRITE_CREATE_EXE)
+	rm -f $(CTVMAKE_EXE)
Index: projectfiles/libretro-android/jni/Android.mk
===================================================================
--- projectfiles/libretro-android/jni/Android.mk	(revision 0)
+++ projectfiles/libretro-android/jni/Android.mk	(working copy)
@@ -0,0 +1,145 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+ifeq ($(TARGET_ARCH),arm)
+LOCAL_CXXFLAGS += -DANDROID_ARM
+LOCAL_ARM_MODE := arm
+LOCAL_C_FLAGS += -fuse-ld=gold
+LOCAL_CPP_FLAGS+= -fuse-ld=gold
+LOCAL_LDLIBS := -fuse-ld=gold
+endif
+
+ifeq ($(TARGET_ARCH),x86)
+LOCAL_CXXFLAGS +=  -DANDROID_X86
+endif
+
+ifeq ($(TARGET_ARCH),mips)
+LOCAL_CXXFLAGS += -DANDROID_MIPS -D__mips__ -D__MIPSEL__
+endif
+
+MAIN_FBA_DIR := ../../../src
+FBA_BURN_DIR := $(MAIN_FBA_DIR)/burn
+FBA_BURN_DRIVERS_DIR := $(MAIN_FBA_DIR)/burn/drv
+FBA_BURNER_DIR := $(MAIN_FBA_DIR)/burner
+LIBRETRO_DIR := $(FBA_BURNER_DIR)/libretro
+FBA_CPU_DIR := $(MAIN_FBA_DIR)/cpu
+FBA_LIB_DIR := $(MAIN_FBA_DIR)/dep/libs
+FBA_INTERFACE_DIR := $(MAIN_FBA_DIR)/intf
+FBA_GENERATED_DIR = $(MAIN_FBA_DIR)/dep/generated
+FBA_SCRIPTS_DIR = $(MAIN_FBA_DIR)/dep/scripts
+
+BURN_BLACKLIST := $(FBA_BURNER_DIR)/un7z.cpp \
+	$(FBA_CPU_DIR)/arm7/arm7exec.c \
+	$(FBA_CPU_DIR)/arm7/arm7core.c \
+	$(FBA_CPU_DIR)/hd6309/6309tbl.c \
+	$(FBA_CPU_DIR)/hd6309/6309ops.c \
+	$(FBA_CPU_DIR)/konami/konamtbl.c \
+	$(FBA_CPU_DIR)/konami/konamops.c \
+	$(FBA_CPU_DIR)/m68k/m68k_in.c \
+	$(FBA_CPU_DIR)/m6800/6800ops.c \
+	$(FBA_CPU_DIR)/m6800/6800tbl.c \
+	$(FBA_CPU_DIR)/m6805/6805ops.c \
+	$(FBA_CPU_DIR)/m6809/6809ops.c \
+	$(FBA_CPU_DIR)/m6809/6809tbl.c \
+	$(FBA_CPU_DIR)/sh2/mksh2.cpp \
+	$(FBA_CPU_DIR)/sh2/mksh2-x86.cpp \
+	$(FBA_CPU_DIR)/m68k/m68kmake.c \
+	$(FBA_BURNER_DIR)/wave_writer.cpp \
+	$(FBA_CPU_DIR)/m68k/m68kdasm.c \
+	$(FBA_LIBRETRO_DIR)/menu.cpp \
+	$(FBA_CPU_DIR)/sh2/mksh2.cpp \
+	$(FBA_BURNER_DIR)/sshot.cpp \
+	$(FBA_BURNER_DIR)/conc.cpp \
+	$(FBA_BURNER_DIR)/dat.cpp \
+	$(FBA_BURNER_DIR)/cong.cpp \
+	$(FBA_BURNER_DIR)/image.cpp \
+	$(FBA_BURNER_DIR)/misc.cpp \
+	$(FBA_CPU_DIR)/h6280/tblh6280.c \
+	$(FBA_CPU_DIR)/m6502/t65sc02.c \
+	$(FBA_CPU_DIR)/m6502/t65c02.c \
+	$(FBA_CPU_DIR)/m6502/tdeco16.c \
+	$(FBA_CPU_DIR)/m6502/tn2a03.c \
+	$(FBA_CPU_DIR)/m6502/t6502.c \
+	$(FBA_CPU_DIR)/nec/v25sfr.c \
+	$(FBA_CPU_DIR)/nec/v25instr.c \
+	$(FBA_CPU_DIR)/nec/necinstr.c \
+	$(FBA_BURN_DIR)/drv/capcom/ctv_make.cpp
+
+FBA_BURN_DIRS := $(FBA_BURN_DIR) \
+	$(FBA_BURN_DIR)/devices \
+	$(FBA_BURN_DIR)/snd \
+	$(FBA_BURN_DRIVERS_DIR)/capcom \
+	$(FBA_BURN_DRIVERS_DIR)/cave \
+	$(FBA_BURN_DRIVERS_DIR)/cps3 \
+	$(FBA_BURN_DRIVERS_DIR)/dataeast \
+	$(FBA_BURN_DRIVERS_DIR)/galaxian \
+	$(FBA_BURN_DRIVERS_DIR)/irem \
+	$(FBA_BURN_DRIVERS_DIR)/konami \
+	$(FBA_BURN_DRIVERS_DIR)/megadrive \
+	$(FBA_BURN_DRIVERS_DIR)/neogeo \
+	$(FBA_BURN_DRIVERS_DIR)/pce \
+	$(FBA_BURN_DRIVERS_DIR)/pgm \
+	$(FBA_BURN_DRIVERS_DIR)/pre90s \
+	$(FBA_BURN_DRIVERS_DIR)/psikyo \
+	$(FBA_BURN_DRIVERS_DIR)/pst90s \
+	$(FBA_BURN_DRIVERS_DIR)/sega \
+	$(FBA_BURN_DRIVERS_DIR)/snes \
+	$(FBA_BURN_DRIVERS_DIR)/taito \
+	$(FBA_BURN_DRIVERS_DIR)/toaplan
+
+FBA_CPU_DIRS := $(FBA_CPU_DIR) \
+	$(FBA_CPU_DIR)/arm \
+	$(FBA_CPU_DIR)/arm7 \
+	$(FBA_CPU_DIR)/h6280 \
+	$(FBA_CPU_DIR)/hd6309 \
+	$(FBA_CPU_DIR)/i8039 \
+	$(FBA_CPU_DIR)/konami \
+	$(FBA_CPU_DIR)/m68k \
+	$(FBA_CPU_DIR)/m6502 \
+	$(FBA_CPU_DIR)/m6800 \
+	$(FBA_CPU_DIR)/m6805 \
+	$(FBA_CPU_DIR)/m6809 \
+	$(FBA_CPU_DIR)/nec \
+	$(FBA_CPU_DIR)/s2650 \
+	$(FBA_CPU_DIR)/sh2 \
+	$(FBA_CPU_DIR)/z80
+
+FBA_LIB_DIRS := $(FBA_LIB_DIR)/zlib
+
+FBA_SRC_DIRS := $(FBA_BURNER_DIR) $(FBA_BURN_DIRS) $(FBA_CPU_DIRS) $(FBA_BURNER_DIRS) $(FBA_LIB_DIRS)
+
+LOCAL_MODULE    := libretro
+
+LOCAL_SRC_FILES := $(filter-out $(BURN_BLACKLIST),$(foreach dir,$(FBA_SRC_DIRS),$(wildcard $(dir)/*.cpp))) $(filter-out $(BURN_BLACKLIST),$(foreach dir,$(FBA_SRC_DIRS),$(wildcard $(dir)/*.c))) $(LIBRETRO_DIR)/libretro.cpp $(LIBRETRO_DIR)/neocdlist.cpp
+
+
+LOCAL_CXXFLAGS += -O3 -fno-stack-protector -DUSE_SPEEDHACKS -DINLINE="static inline" -DSH2_INLINE="static inline" -D__LIBRETRO_OPTIMIZATIONS__ -DLSB_FIRST -D__LIBRETRO__ -Wno-write-strings -DUSE_FILE32API -DANDROID -DFRONTEND_SUPPORTS_RGB565
+LOCAL_CFLAGS = -O3 -fno-stack-protector -DUSE_SPEEDHACKS -DINLINE="static inline" -DSH2_INLINE="static inline" -D__LIBRETRO_OPTIMIZATIONS__ -DLSB_FIRST -D__LIBRETRO__ -Wno-write-strings -DUSE_FILE32API -DANDROID -DFRONTEND_SUPPORTS_RGB565
+
+LOCAL_C_INCLUDES = $(FBA_BURNER_DIR)/win32 \
+	$(LIBRETRO_DIR) \
+	$(LIBRETRO_DIR)/tchar \
+	$(FBA_BURN_DIR) \
+	$(MAIN_FBA_DIR)/cpu \
+	$(FBA_BURN_DIR)/snd \
+	$(FBA_BURN_DIR)/devices \
+	$(FBA_INTERFACE_DIR) \
+	$(FBA_INTERFACE_DIR)/input \
+	$(FBA_INTERFACE_DIR)/cd \
+	$(FBA_BURNER_DIR) \
+	$(FBA_CPU_DIR) \
+	$(FBA_CPU_DIR)/i8039 \
+	$(FBA_LIB_DIR)/zlib \
+	$(FBA_BURN_DIR)/drv/capcom \
+	$(FBA_BURN_DIR)/drv/dataeast \
+	$(FBA_BURN_DIR)/drv/cave \
+	$(FBA_BURN_DIR)/drv/neogeo \
+	$(FBA_BURN_DIR)/drv/psikyo \
+	$(FBA_BURN_DIR)/drv/sega \
+	$(FBA_BURN_DIR)/drv/toaplan \
+	$(FBA_BURN_DIR)/drv/taito \
+	$(FBA_GENERATED_DIR) \
+	$(FBA_LIB_DIR)
+
+include $(BUILD_SHARED_LIBRARY)
Index: projectfiles/libretro-android/jni/Application.mk
===================================================================
--- projectfiles/libretro-android/jni/Application.mk	(revision 0)
+++ projectfiles/libretro-android/jni/Application.mk	(working copy)
@@ -0,0 +1,2 @@
+APP_STL := stlport_static
+APP_ABI := all
Index: projectfiles/visualstudio-2003-libretro-xbox1/fba_vs2003_libretro_xbox1.sln
===================================================================
--- projectfiles/visualstudio-2003-libretro-xbox1/fba_vs2003_libretro_xbox1.sln	(revision 0)
+++ projectfiles/visualstudio-2003-libretro-xbox1/fba_vs2003_libretro_xbox1.sln	(working copy)
@@ -0,0 +1,30 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "visualstudio-2003-libretro-xbox1", "fba_vs2003_libretro_xbox1.vcproj", "{812368D1-1F0C-4480-81F1-7FB1EC247E58}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Profile = Profile
+		Profile_FastCap = Profile_FastCap
+		Release = Release
+		Release_LTCG = Release_LTCG
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Debug.ActiveCfg = Debug|Xbox
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Debug.Build.0 = Debug|Xbox
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Profile.ActiveCfg = Profile|Xbox
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Profile.Build.0 = Profile|Xbox
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Profile_FastCap.ActiveCfg = Profile_FastCap|Xbox
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Profile_FastCap.Build.0 = Profile_FastCap|Xbox
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Release.ActiveCfg = Release|Xbox
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Release.Build.0 = Release|Xbox
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Release_LTCG.ActiveCfg = Release_LTCG|Xbox
+		{812368D1-1F0C-4480-81F1-7FB1EC247E58}.Release_LTCG.Build.0 = Release_LTCG|Xbox
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
Index: projectfiles/visualstudio-2003-libretro-xbox1/fba_vs2003_libretro_xbox1.vcproj
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/xml
Index: projectfiles/visualstudio-2003-libretro-xbox1/fba_vs2003_libretro_xbox1.vcproj
===================================================================
--- projectfiles/visualstudio-2003-libretro-xbox1/fba_vs2003_libretro_xbox1.vcproj	(revision 847)
+++ projectfiles/visualstudio-2003-libretro-xbox1/fba_vs2003_libretro_xbox1.vcproj	(working copy)

Property changes on: projectfiles/visualstudio-2003-libretro-xbox1/fba_vs2003_libretro_xbox1.vcproj
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/xml
\ No newline at end of property
Index: projectfiles/visualstudio-2003-libretro-xbox1/stdint.h
===================================================================
--- projectfiles/visualstudio-2003-libretro-xbox1/stdint.h	(revision 0)
+++ projectfiles/visualstudio-2003-libretro-xbox1/stdint.h	(working copy)
@@ -0,0 +1,249 @@
+// ISO C9x  compliant stdint.h for Microsoft Visual Studio
+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 
+// 
+//  Copyright (c) 2006-2008 Alexander Chemeris
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//   1. Redistributions of source code must retain the above copyright notice,
+//      this list of conditions and the following disclaimer.
+// 
+//   2. Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+// 
+//   3. The name of the author may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+///////////////////////////////////////////////////////////////////////////////
+#ifndef __RARCH_STDINT_H
+#define __RARCH_STDINT_H
+
+#if _MSC_VER && (_MSC_VER < 1600)
+//pre-MSVC 2010 needs an implementation of stdint.h
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include <limits.h>
+
+// For Visual Studio 6 in C++ mode and for many Visual Studio versions when
+// compiling for ARM we should wrap <wchar.h> include with 'extern "C++" {}'
+// or compiler give many errors like this:
+//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed
+#ifdef __cplusplus
+extern "C" {
+#endif
+#  include <wchar.h>
+#ifdef __cplusplus
+}
+#endif
+
+// Define _W64 macros to mark types changing their size, like intptr_t.
+#ifndef _W64
+#  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
+#     define _W64 __w64
+#  else
+#     define _W64
+#  endif
+#endif
+
+
+// 7.18.1 Integer types
+
+// 7.18.1.1 Exact-width integer types
+
+// Visual Studio 6 and Embedded Visual C++ 4 doesn't
+// realize that, e.g. char has the same size as __int8
+// so we give up on __intX for them.
+#if (_MSC_VER < 1300)
+   typedef signed char       int8_t;
+   typedef signed short      int16_t;
+   typedef signed int        int32_t;
+   typedef unsigned char     uint8_t;
+   typedef unsigned short    uint16_t;
+   typedef unsigned int      uint32_t;
+#else
+   typedef signed __int8     int8_t;
+   typedef signed __int16    int16_t;
+   typedef signed __int32    int32_t;
+   typedef unsigned __int8   uint8_t;
+   typedef unsigned __int16  uint16_t;
+   typedef unsigned __int32  uint32_t;
+#endif
+typedef signed __int64       int64_t;
+typedef unsigned __int64     uint64_t;
+
+
+// 7.18.1.2 Minimum-width integer types
+typedef int8_t    int_least8_t;
+typedef int16_t   int_least16_t;
+typedef int32_t   int_least32_t;
+typedef int64_t   int_least64_t;
+typedef uint8_t   uint_least8_t;
+typedef uint16_t  uint_least16_t;
+typedef uint32_t  uint_least32_t;
+typedef uint64_t  uint_least64_t;
+
+// 7.18.1.3 Fastest minimum-width integer types
+typedef int8_t    int_fast8_t;
+typedef int16_t   int_fast16_t;
+typedef int32_t   int_fast32_t;
+typedef int64_t   int_fast64_t;
+typedef uint8_t   uint_fast8_t;
+typedef uint16_t  uint_fast16_t;
+typedef uint32_t  uint_fast32_t;
+typedef uint64_t  uint_fast64_t;
+
+// 7.18.1.4 Integer types capable of holding object pointers
+#ifdef _WIN64 // [
+   typedef signed __int64    intptr_t;
+   typedef unsigned __int64  uintptr_t;
+#else // _WIN64 ][
+   typedef _W64 signed int   intptr_t;
+   typedef _W64 unsigned int uintptr_t;
+#endif // _WIN64 ]
+
+// 7.18.1.5 Greatest-width integer types
+typedef int64_t   intmax_t;
+typedef uint64_t  uintmax_t;
+
+
+// 7.18.2 Limits of specified-width integer types
+
+#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259
+
+// 7.18.2.1 Limits of exact-width integer types
+#define INT8_MIN     ((int8_t)_I8_MIN)
+#define INT8_MAX     _I8_MAX
+#define INT16_MIN    ((int16_t)_I16_MIN)
+#define INT16_MAX    _I16_MAX
+#define INT32_MIN    ((int32_t)_I32_MIN)
+#define INT32_MAX    _I32_MAX
+#define INT64_MIN    ((int64_t)_I64_MIN)
+#define INT64_MAX    _I64_MAX
+#define UINT8_MAX    _UI8_MAX
+#define UINT16_MAX   _UI16_MAX
+#define UINT32_MAX   _UI32_MAX
+#define UINT64_MAX   _UI64_MAX
+
+// 7.18.2.2 Limits of minimum-width integer types
+#define INT_LEAST8_MIN    INT8_MIN
+#define INT_LEAST8_MAX    INT8_MAX
+#define INT_LEAST16_MIN   INT16_MIN
+#define INT_LEAST16_MAX   INT16_MAX
+#define INT_LEAST32_MIN   INT32_MIN
+#define INT_LEAST32_MAX   INT32_MAX
+#define INT_LEAST64_MIN   INT64_MIN
+#define INT_LEAST64_MAX   INT64_MAX
+#define UINT_LEAST8_MAX   UINT8_MAX
+#define UINT_LEAST16_MAX  UINT16_MAX
+#define UINT_LEAST32_MAX  UINT32_MAX
+#define UINT_LEAST64_MAX  UINT64_MAX
+
+// 7.18.2.3 Limits of fastest minimum-width integer types
+#define INT_FAST8_MIN    INT8_MIN
+#define INT_FAST8_MAX    INT8_MAX
+#define INT_FAST16_MIN   INT16_MIN
+#define INT_FAST16_MAX   INT16_MAX
+#define INT_FAST32_MIN   INT32_MIN
+#define INT_FAST32_MAX   INT32_MAX
+#define INT_FAST64_MIN   INT64_MIN
+#define INT_FAST64_MAX   INT64_MAX
+#define UINT_FAST8_MAX   UINT8_MAX
+#define UINT_FAST16_MAX  UINT16_MAX
+#define UINT_FAST32_MAX  UINT32_MAX
+#define UINT_FAST64_MAX  UINT64_MAX
+
+// 7.18.2.4 Limits of integer types capable of holding object pointers
+#ifdef _WIN64 // [
+#  define INTPTR_MIN   INT64_MIN
+#  define INTPTR_MAX   INT64_MAX
+#  define UINTPTR_MAX  UINT64_MAX
+#else // _WIN64 ][
+#  define INTPTR_MIN   INT32_MIN
+#  define INTPTR_MAX   INT32_MAX
+#  define UINTPTR_MAX  UINT32_MAX
+#endif // _WIN64 ]
+
+// 7.18.2.5 Limits of greatest-width integer types
+#define INTMAX_MIN   INT64_MIN
+#define INTMAX_MAX   INT64_MAX
+#define UINTMAX_MAX  UINT64_MAX
+
+// 7.18.3 Limits of other integer types
+
+#ifdef _WIN64 // [
+#  define PTRDIFF_MIN  _I64_MIN
+#  define PTRDIFF_MAX  _I64_MAX
+#else  // _WIN64 ][
+#  define PTRDIFF_MIN  _I32_MIN
+#  define PTRDIFF_MAX  _I32_MAX
+#endif  // _WIN64 ]
+
+#define SIG_ATOMIC_MIN  INT_MIN
+#define SIG_ATOMIC_MAX  INT_MAX
+
+#ifndef SIZE_MAX // [
+#  ifdef _WIN64 // [
+#     define SIZE_MAX  _UI64_MAX
+#  else // _WIN64 ][
+#     define SIZE_MAX  _UI32_MAX
+#  endif // _WIN64 ]
+#endif // SIZE_MAX ]
+
+// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>
+#ifndef WCHAR_MIN // [
+#  define WCHAR_MIN  0
+#endif  // WCHAR_MIN ]
+#ifndef WCHAR_MAX // [
+#  define WCHAR_MAX  _UI16_MAX
+#endif  // WCHAR_MAX ]
+
+#define WINT_MIN  0
+#define WINT_MAX  _UI16_MAX
+
+#endif // __STDC_LIMIT_MACROS ]
+
+
+// 7.18.4 Limits of other integer types
+
+#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260
+
+// 7.18.4.1 Macros for minimum-width integer constants
+
+#define INT8_C(val)  val##i8
+#define INT16_C(val) val##i16
+#define INT32_C(val) val##i32
+#define INT64_C(val) val##i64
+
+#define UINT8_C(val)  val##ui8
+#define UINT16_C(val) val##ui16
+#define UINT32_C(val) val##ui32
+#define UINT64_C(val) val##ui64
+
+// 7.18.4.2 Macros for greatest-width integer constants
+#define INTMAX_C   INT64_C
+#define UINTMAX_C  UINT64_C
+
+#endif // __STDC_CONSTANT_MACROS ]
+
+#else
+//sanity for everything else
+#include <stdint.h>
+#endif
+
+#endif
Index: projectfiles/visualstudio-2003-libretro-xbox1/zconf.h
===================================================================
--- projectfiles/visualstudio-2003-libretro-xbox1/zconf.h	(revision 0)
+++ projectfiles/visualstudio-2003-libretro-xbox1/zconf.h	(working copy)
@@ -0,0 +1,327 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZCONF_H
+#define ZCONF_H
+
+/* added for file_extractor; OK to remove, just increases executable size */
+#define DYNAMIC_CRC_TABLE
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_          z_deflateInit_
+#  define deflate               z_deflate
+#  define deflateEnd            z_deflateEnd
+#  define inflateInit_          z_inflateInit_
+#  define inflate               z_inflate
+#  define inflateEnd            z_inflateEnd
+#  define deflateInit2_         z_deflateInit2_
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateCopy           z_deflateCopy
+#  define deflateReset          z_deflateReset
+#  define deflateParams         z_deflateParams
+#  define deflateBound          z_deflateBound
+#  define deflatePrime          z_deflatePrime
+#  define inflateInit2_         z_inflateInit2_
+#  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateSync           z_inflateSync
+#  define inflateSyncPoint      z_inflateSyncPoint
+#  define inflateCopy           z_inflateCopy
+#  define inflateReset          z_inflateReset
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define compress              z_compress
+#  define compress2             z_compress2
+#  define compressBound         z_compressBound
+#  define uncompress            z_uncompress
+#  define adler32               z_adler32
+#  define crc32                 z_crc32
+#  define get_crc_table         z_get_crc_table
+#  define zError                z_zError
+
+#  define alloc_func            z_alloc_func
+#  define free_func             z_free_func
+#  define in_func               z_in_func
+#  define out_func              z_out_func
+#  define Byte                  z_Byte
+#  define uInt                  z_uInt
+#  define uLong                 z_uLong
+#  define Bytef                 z_Bytef
+#  define charf                 z_charf
+#  define intf                  z_intf
+#  define uIntf                 z_uIntf
+#  define uLongf                z_uLongf
+#  define voidpf                z_voidpf
+#  define voidp                 z_voidp
+#endif
+
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) && !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
+#  ifndef WIN32
+#    define WIN32
+#  endif
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
+#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ >= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+     /* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+     /* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+   /* If building or using zlib as a DLL, define ZLIB_DLL.
+    * This is not mandatory, but it offers a little performance increase.
+    */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
+    * define ZLIB_WINAPI.
+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+    */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+     /* No need for _export, use ZLIB.DEF instead. */
+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void const *voidpc;
+   typedef void FAR   *voidpf;
+   typedef void       *voidp;
+#else
+   typedef Byte const *voidpc;
+   typedef Byte FAR   *voidpf;
+   typedef Byte       *voidp;
+#endif
+
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define z_off_t long
+#endif
+
+#if defined(__OS400__)
+#  define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(deflateBound,"DEBND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(compressBound,"CMBND")
+#   pragma map(inflate_table,"INTABL")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_copyright,"INCOPY")
+#endif
+
+#endif /* ZCONF_H */
Index: projectfiles/visualstudio-2003-libretro-xbox1/zlib.h
===================================================================
--- projectfiles/visualstudio-2003-libretro-xbox1/zlib.h	(revision 0)
+++ projectfiles/visualstudio-2003-libretro-xbox1/zlib.h	(working copy)
@@ -0,0 +1,1357 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.3, July 18th, 2005
+
+  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#include "zconf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.2.3"
+#define ZLIB_VERNUM 0x1230
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio using the functions that start
+  with "gz".  The gzip format is different from the zlib format.  gzip is a
+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+     This library can optionally read and write gzip streams in memory as well.
+
+     The zlib format was designed to be compact and fast for use in memory
+  and on communications channels.  The gzip format was designed for single-
+  file compression on file systems, has a larger header than zlib to maintain
+  directory information, and uses a different, slower check method than zlib.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    const char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: binary or text */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+     gzip header information passed to and from zlib routines.  See RFC 1952
+  for more details on the meanings of these fields.
+*/
+typedef struct gz_header_s {
+    int     text;       /* true if compressed data believed to be text */
+    uLong   time;       /* modification time */
+    int     xflags;     /* extra flags (not used when writing a gzip file) */
+    int     os;         /* operating system */
+    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
+    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
+    uInt    extra_max;  /* space at extra (only when reading header) */
+    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
+    uInt    name_max;   /* space at name (only when reading header) */
+    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
+    uInt    comm_max;   /* space at comment (only when reading header) */
+    int     hcrc;       /* true if there was or will be a header crc */
+    int     done;       /* true when done reading gzip header (not used
+                           when writing a gzip file) */
+} gz_header;
+
+typedef gz_header FAR *gz_headerp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+/* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_FIXED               4
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_TEXT     1
+#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions < 1.0.2 */
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/*
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce some
+  output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows. deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
+  decide how much data to accumualte before producing output, in order to
+  maximize compression.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far. (In particular
+  avail_in is zero after the call if enough output space has been provided
+  before the call.)  Flushing may degrade compression for some compression
+  algorithms and so it should be used only when necessary.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+  avail_out is greater than six to avoid repeated flush markers due to
+  avail_out == 0 on return.
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  the value returned by deflateBound (see below). If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm->adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update strm->data_type if it can make a good guess about
+  the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
+  fatal, and deflate() can be called again with more input and more output
+  space to continue compressing.
+*/
+
+
+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/*
+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+   value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller.  msg is set to null if there is no error
+   message. inflateInit does not perform any decompression apart from reading
+   the zlib header if present: this will be done by inflate().  (So next_in and
+   avail_in may be modified, but next_out and avail_out are unchanged.)
+*/
+
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+  if and when it gets to the next deflate block boundary. When decoding the
+  zlib or gzip format, this will cause inflate() to return immediately after
+  the header and before the first block. When doing a raw inflate, inflate()
+  will go ahead and process the first block, and will return when it gets to
+  the end of that block, or when it runs out of data.
+
+    The Z_BLOCK option assists in appending to or combining deflate streams.
+  Also to assist in this, on return inflate() will set strm->data_type to the
+  number of unused bits in the last byte taken from strm->next_in, plus 64
+  if inflate() is currently decoding the last block in the deflate stream,
+  plus 128 if inflate() returned immediately after decoding an end-of-block
+  code or decoding the complete header up to just before the first byte of the
+  deflate stream. The end-of-block will not be indicated until all of the
+  uncompressed data from that block has been written to strm->next_out.  The
+  number of unused bits may in general be greater than seven, except when
+  bit 7 of data_type is set, in which case the number of unused bits will be
+  less than eight.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster approach
+  may be used for the single inflate() call.
+
+     In this implementation, inflate() always flushes as much output as
+  possible to the output buffer, and always uses the faster approach on the
+  first call. So the only effect of the flush parameter in this implementation
+  is on the return value of inflate(), as noted below, or when it returns early
+  because Z_BLOCK is used.
+
+     If a preset dictionary is needed after this call (see inflateSetDictionary
+  below), inflate sets strm->adler to the adler32 checksum of the dictionary
+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+  strm->adler to the adler32 checksum of all output produced so far (that is,
+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+  below. At the end of the stream, inflate() checks that its computed adler32
+  checksum is equal to that saved by the compressor and returns Z_STREAM_END
+  only if the checksum is correct.
+
+    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically.  Any information
+  contained in the gzip header is not retained, so applications that need that
+  information should instead use raw inflate, see inflateInit2() below, or
+  inflateBack() and perform their own processing of the gzip header and
+  trailer.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect check
+  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+  inflate() can be called again with more input and more output space to
+  continue decompressing. If Z_DATA_ERROR is returned, the application may then
+  call inflateSync() to look for a good compression block if a partial recovery
+  of the data is desired.
+*/
+
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer). It should be in the range 8..15 for this
+   version of the library. Larger values of this parameter result in better
+   compression at the expense of memory usage. The default value is 15 if
+   deflateInit is used instead.
+
+     windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
+   determines the window size. deflate() will then generate raw deflate data
+   with no zlib header or trailer, and will not compute an adler32 check value.
+
+     windowBits can also be greater than 15 for optional gzip encoding. Add
+   16 to windowBits to write a simple gzip header and trailer around the
+   compressed data instead of a zlib wrapper. The gzip header will have no
+   file name, no extra data, no comment, no modification time (set to zero),
+   no header crc, and the operating system will be set to 255 (unknown).  If a
+   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match), or Z_RLE to limit match distances to one (run-length
+   encoding). Filtered data consists mostly of small values with a somewhat
+   random distribution. In this case, the compression algorithm is tuned to
+   compress them better. The effect of Z_FILTERED is to force more Huffman
+   coding and less string matching; it is somewhat intermediate between
+   Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
+   Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
+   parameter only affects the compression ratio but not the correctness of the
+   compressed output even if it is not set appropriately.  Z_FIXED prevents the
+   use of dynamic Huffman codes, allowing for a simpler decoder for special
+   applications.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+   method). msg is set to null if there is no error message.  deflateInit2 does
+   not perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output. This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any
+   call of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size in
+   deflate or deflate2. Thus the strings most likely to be useful should be
+   put at the end of the dictionary, not at the front. In addition, the
+   current implementation of deflate will use at most the window size minus
+   262 bytes of the provided dictionary.
+
+     Upon return of this function, strm->adler is set to the adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.) If a raw deflate was requested, then the
+   adler32 value is not computed and strm->adler is not set.
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort). deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+                                      int level,
+                                      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different
+   strategy. If the compression level is changed, the input available so far
+   is compressed with the old level (and may be flushed); the new level will
+   take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm->avail_out was zero.
+*/
+
+ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
+                                    int good_length,
+                                    int max_lazy,
+                                    int nice_length,
+                                    int max_chain));
+/*
+     Fine tune deflate's internal compression parameters.  This should only be
+   used by someone who understands the algorithm used by zlib's deflate for
+   searching for the best matching string, and even then only by the most
+   fanatic optimizer trying to squeeze out the last compressed bit for their
+   specific input data.  Read the deflate.c source code for the meaning of the
+   max_lazy, good_length, nice_length, and max_chain parameters.
+
+     deflateTune() can be called after deflateInit() or deflateInit2(), and
+   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
+ */
+
+ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
+                                       uLong sourceLen));
+/*
+     deflateBound() returns an upper bound on the compressed size after
+   deflation of sourceLen bytes.  It must be called after deflateInit()
+   or deflateInit2().  This would be used to allocate an output buffer
+   for deflation in a single pass, and so would be called before deflate().
+*/
+
+ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     deflatePrime() inserts bits in the deflate output stream.  The intent
+  is that this function is used to start off the deflate output with the
+  bits leftover from a previous deflate stream when appending to it.  As such,
+  this function can only be used for raw deflate, and must be used before the
+  first deflate() call after a deflateInit2() or deflateReset().  bits must be
+  less than or equal to 16, and that many of the least significant bits of
+  value will be inserted in the output.
+
+      deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+      deflateSetHeader() provides gzip header information for when a gzip
+   stream is requested by deflateInit2().  deflateSetHeader() may be called
+   after deflateInit2() or deflateReset() and before the first call of
+   deflate().  The text, time, os, extra field, name, and comment information
+   in the provided gz_header structure are written to the gzip header (xflag is
+   ignored -- the extra flags are set according to the compression level).  The
+   caller must assure that, if not Z_NULL, name and comment are terminated with
+   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
+   available there.  If hcrc is true, a gzip header crc is included.  Note that
+   the current versions of the command-line version of gzip (up through version
+   1.3.x) do not support header crc's, and will report that it is a "multi-part
+   gzip file" and give up.
+
+      If deflateSetHeader is not used, the default gzip header has text false,
+   the time set to zero, and os set to 255, with no extra, name, or comment
+   fields.  The gzip header is returned to the default state by deflateReset().
+
+      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter. The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library. The default value is 15 if inflateInit is used
+   instead. windowBits must be greater than or equal to the windowBits value
+   provided to deflateInit2() while compressing, or it must be equal to 15 if
+   deflateInit2() was not used. If a compressed stream with a larger window
+   size is given as input, inflate() will return with the error code
+   Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
+   determines the window size. inflate() will then process raw deflate data,
+   not looking for a zlib or gzip header, not generating a check value, and not
+   looking for any check values for comparison at the end of the stream. This
+   is for use with other formats that use the deflate compressed data format
+   such as zip.  Those formats provide their own check values. If a custom
+   format is developed using the raw deflate format for compressed data, it is
+   recommended that a check value such as an adler32 or a crc32 be applied to
+   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
+   most applications, the zlib format should be used as is. Note that comments
+   above on the use in deflateInit2() applies to the magnitude of windowBits.
+
+     windowBits can also be greater than 15 for optional gzip decoding. Add
+   32 to windowBits to enable zlib and gzip decoding with automatic header
+   detection, or add 16 to decode only the gzip format (the zlib format will
+   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is
+   a crc32 instead of an adler32.
+
+     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg
+   is set to null if there is no error message.  inflateInit2 does not perform
+   any decompression apart from reading the zlib header if present: this will
+   be done by inflate(). (So next_in and avail_in may be modified, but next_out
+   and avail_out are unchanged.)
+*/
+
+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence. This function must be called immediately after a call of inflate,
+   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the adler32 value returned by that call of inflate.
+   The compressor and decompressor must use exactly the same dictionary (see
+   deflateSetDictionary).  For raw inflate, this function can be called
+   immediately after inflateInit2() or inflateReset() and before any call of
+   inflate() to set the dictionary.  The application must insure that the
+   dictionary that was used for compression is provided.
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+/*
+    Skips invalid compressed data until a full flush point (see above the
+  description of deflate with Z_FULL_FLUSH) can be found, or until all
+  available input is skipped. No output is provided.
+
+    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when randomly accessing a large stream.  The
+   first pass through the stream can periodically record the inflate state,
+   allowing restarting inflate at those points when randomly accessing the
+   stream.
+
+     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     This function inserts bits in the inflate input stream.  The intent is
+  that this function is used to start inflating at a bit position in the
+  middle of a byte.  The provided bits will be used before any bytes are used
+  from next_in.  This function should only be used with raw inflate, and
+  should be used before the first inflate() call after inflateInit2() or
+  inflateReset().  bits must be less than or equal to 16, and that many of the
+  least significant bits of value will be inserted in the input.
+
+      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+      inflateGetHeader() requests that gzip header information be stored in the
+   provided gz_header structure.  inflateGetHeader() may be called after
+   inflateInit2() or inflateReset(), and before the first call of inflate().
+   As inflate() processes the gzip stream, head->done is zero until the header
+   is completed, at which time head->done is set to one.  If a zlib stream is
+   being decoded, then head->done is set to -1 to indicate that there will be
+   no gzip header information forthcoming.  Note that Z_BLOCK can be used to
+   force inflate() to return immediately after header processing is complete
+   and before any actual data is decompressed.
+
+      The text, time, xflags, and os fields are filled in with the gzip header
+   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
+   was valid if done is set to one.)  If extra is not Z_NULL, then extra_max
+   contains the maximum number of bytes to write to extra.  Once done is true,
+   extra_len contains the actual extra field length, and extra contains the
+   extra field, or that field truncated if extra_max is less than extra_len.
+   If name is not Z_NULL, then up to name_max characters are written there,
+   terminated with a zero unless the length is greater than name_max.  If
+   comment is not Z_NULL, then up to comm_max characters are written there,
+   terminated with a zero unless the length is greater than comm_max.  When
+   any of extra, name, or comment are not Z_NULL and the respective field is
+   not present in the header, then that field is set to Z_NULL to signal its
+   absence.  This allows the use of deflateSetHeader() with the returned
+   structure to duplicate the header.  However if those fields are set to
+   allocated memory, then the application will need to save those pointers
+   elsewhere so that they can be eventually freed.
+
+      If inflateGetHeader is not used, then the header information is simply
+   discarded.  The header is always checked for validity, including the header
+   CRC if present.  inflateReset() will reset the process to discard the header
+   information.  The application would need to call inflateGetHeader() again to
+   retrieve the header from the next gzip stream.
+
+      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
+                                        unsigned char FAR *window));
+
+     Initialize the internal stream state for decompression using inflateBack()
+   calls.  The fields zalloc, zfree and opaque in strm must be initialized
+   before the call.  If zalloc and zfree are Z_NULL, then the default library-
+   derived memory allocation routines are used.  windowBits is the base two
+   logarithm of the window size, in the range 8..15.  window is a caller
+   supplied buffer of that size.  Except for special applications where it is
+   assured that deflate was used with small window sizes, windowBits must be 15
+   and a 32K byte window must be supplied to be able to decompress general
+   deflate streams.
+
+     See inflateBack() for the usage of these routines.
+
+     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
+   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
+   be allocated, or Z_VERSION_ERROR if the version of the library does not
+   match the version of the header file.
+*/
+
+typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
+typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
+
+ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
+                                    in_func in, void FAR *in_desc,
+                                    out_func out, void FAR *out_desc));
+/*
+     inflateBack() does a raw inflate with a single call using a call-back
+   interface for input and output.  This is more efficient than inflate() for
+   file i/o applications in that it avoids copying between the output and the
+   sliding window by simply making the window itself the output buffer.  This
+   function trusts the application to not change the output buffer passed by
+   the output function, at least until inflateBack() returns.
+
+     inflateBackInit() must be called first to allocate the internal state
+   and to initialize the state with the user-provided window buffer.
+   inflateBack() may then be used multiple times to inflate a complete, raw
+   deflate stream with each call.  inflateBackEnd() is then called to free
+   the allocated state.
+
+     A raw deflate stream is one with no zlib or gzip header or trailer.
+   This routine would normally be used in a utility that reads zip or gzip
+   files and writes out uncompressed files.  The utility would decode the
+   header and process the trailer on its own, hence this routine expects
+   only the raw deflate stream to decompress.  This is different from the
+   normal behavior of inflate(), which expects either a zlib or gzip header and
+   trailer around the deflate stream.
+
+     inflateBack() uses two subroutines supplied by the caller that are then
+   called by inflateBack() for input and output.  inflateBack() calls those
+   routines until it reads a complete deflate stream and writes out all of the
+   uncompressed data, or until it encounters an error.  The function's
+   parameters and return types are defined above in the in_func and out_func
+   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
+   number of bytes of provided input, and a pointer to that input in buf.  If
+   there is no input available, in() must return zero--buf is ignored in that
+   case--and inflateBack() will return a buffer error.  inflateBack() will call
+   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
+   should return zero on success, or non-zero on failure.  If out() returns
+   non-zero, inflateBack() will return with an error.  Neither in() nor out()
+   are permitted to change the contents of the window provided to
+   inflateBackInit(), which is also the buffer that out() uses to write from.
+   The length written by out() will be at most the window size.  Any non-zero
+   amount of input may be provided by in().
+
+     For convenience, inflateBack() can be provided input on the first call by
+   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
+   in() will be called.  Therefore strm->next_in must be initialized before
+   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
+   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
+   must also be initialized, and then if strm->avail_in is not zero, input will
+   initially be taken from strm->next_in[0 .. strm->avail_in - 1].
+
+     The in_desc and out_desc parameters of inflateBack() is passed as the
+   first parameter of in() and out() respectively when they are called.  These
+   descriptors can be optionally used to pass any information that the caller-
+   supplied in() and out() functions need to do their job.
+
+     On return, inflateBack() will set strm->next_in and strm->avail_in to
+   pass back any unused input that was provided by the last in() call.  The
+   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
+   if in() or out() returned an error, Z_DATA_ERROR if there was a format
+   error in the deflate stream (in which case strm->msg is set to indicate the
+   nature of the error), or Z_STREAM_ERROR if the stream was not properly
+   initialized.  In the case of Z_BUF_ERROR, an input or output error can be
+   distinguished using strm->next_in which will be Z_NULL only if in() returned
+   an error.  If strm->next is not Z_NULL, then the Z_BUF_ERROR was due to
+   out() returning non-zero.  (in() will always be called before out(), so
+   strm->next_in is assured to be defined if out() returns non-zero.)  Note
+   that inflateBack() cannot return Z_OK.
+*/
+
+ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
+/*
+     All memory allocated by inflateBackInit() is freed.
+
+     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
+   state was inconsistent.
+*/
+
+ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
+/* Return flags indicating compile-time options.
+
+    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
+     1.0: size of uInt
+     3.2: size of uLong
+     5.4: size of voidpf (pointer)
+     7.6: size of z_off_t
+
+    Compiler, assembler, and debug options:
+     8: DEBUG
+     9: ASMV or ASMINF -- use ASM code
+     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
+     11: 0 (reserved)
+
+    One-time table building (smaller code, but not thread-safe if true):
+     12: BUILDFIXED -- build static block decoding tables when needed
+     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
+     14,15: 0 (reserved)
+
+    Library content (indicates missing functionality):
+     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
+                          deflate code when not needed)
+     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
+                    and decode gzip streams (to avoid linking crc code)
+     18-19: 0 (reserved)
+
+    Operation variations (changes in library functionality):
+     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
+     21: FASTEST -- deflate algorithm with only one, lowest compression level
+     22,23: 0 (reserved)
+
+    The sprintf variant used by gzprintf (zero is best):
+     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
+     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
+     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
+
+    Remainder:
+     27-31: 0 (reserved)
+ */
+
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
+                                 const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least the value returned
+   by compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level));
+/*
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least the value returned by
+   compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+
+ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
+/*
+     compressBound() returns an upper bound on the compressed size after
+   compress() or compress2() on sourceLen bytes.  It would be used before
+   a compress() or compress2() call to allocate the destination buffer.
+*/
+
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+*/
+
+
+typedef voidp gzFile;
+
+ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb") but can also include a compression level
+   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
+   Huffman only compression as in "wb1h", or 'R' for run-length encoding
+   as in "wb1R". (See the description of deflateInit2 for more information
+   about the strategy parameter.)
+
+     gzopen can be used to read a file which is not in gzip format; in this
+   case gzread will directly read from the file without decompression.
+
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).  */
+
+ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+/*
+     Dynamically update the compression level or strategy. See the description
+   of deflateInit2 for the meaning of these parameters.
+     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+   opened for writing.
+*/
+
+ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
+                                   voidpc buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+/*
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).  The number of
+   uncompressed bytes written is limited to 4095. The caller should assure that
+   this limit is not exceeded. If it is exceeded, then gzprintf() will return
+   return an error (0) with nothing written. In this case, there may also be a
+   buffer overflow with unpredictable consequences, which is possible only if
+   zlib was compiled with the insecure functions sprintf() or vsprintf()
+   because the secure snprintf() or vsnprintf() functions were not available.
+*/
+
+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+/*
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+
+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+/*
+      Reads bytes from the compressed file until len-1 characters are read, or
+   a newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  The string is then terminated with a null
+   character.
+      gzgets returns buf, or Z_NULL in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+/*
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+/*
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+
+ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
+/*
+      Push one character back onto the stream to be read again later.
+   Only one character of push-back is allowed.  gzungetc() returns the
+   character pushed, or -1 on failure.  gzungetc() will fail if a
+   character has been pushed but not read yet, or if c is -1. The pushed
+   character will be discarded if the stream is repositioned with gzseek()
+   or gzrewind().
+*/
+
+ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+                                      z_off_t offset, int whence));
+/*
+      Sets the starting position for the next gzread or gzwrite on the
+   given compressed file. The offset represents a number of bytes in the
+   uncompressed data stream. The whence parameter is defined as in lseek(2);
+   the value SEEK_END is not supported.
+     If the file is opened for reading, this function is emulated but can be
+   extremely slow. If the file is opened for writing, only forward seeks are
+   supported; gzseek then compresses a sequence of zeroes up to the new
+   starting position.
+
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error, in
+   particular if the file is opened for writing and the new starting position
+   would be before the current position.
+*/
+
+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+/*
+     Rewinds the given file. This function is supported only for reading.
+
+   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+*/
+
+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+/*
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+
+   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
+ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+/*
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+
+ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
+/*
+     Returns 1 if file is being read directly without decompression, otherwise
+   zero.
+*/
+
+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
+/*
+     Clears the error and end-of-file flags for file. This is analogous to the
+   clearerr() function in stdio. This is useful for continuing to read a gzip
+   file that is being written concurrently.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
+                                          z_off_t len2));
+/*
+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running CRC-32 with the bytes buf[0..len-1] and return the
+   updated CRC-32. If buf is NULL, this function returns the required initial
+   value for the for the crc. Pre- and post-conditioning (one's complement) is
+   performed within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
+
+/*
+     Combine two CRC-32 check values into one.  For two sequences of bytes,
+   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
+   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
+   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
+   len2.
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
+                                         unsigned char FAR *window,
+                                         const char *version,
+                                         int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+#define inflateBackInit(strm, windowBits, window) \
+        inflateBackInit_((strm), (windowBits), (window), \
+        ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+ZEXTERN const char   * ZEXPORT zError           OF((int));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */
Index: projectfiles/visualstudio-2010-libretro-360/fba_vs2010_libretro_360.vcxproj
===================================================================
--- projectfiles/visualstudio-2010-libretro-360/fba_vs2010_libretro_360.vcxproj	(revision 847)
+++ projectfiles/visualstudio-2010-libretro-360/fba_vs2010_libretro_360.vcxproj	(working copy)
@@ -66,10 +66,15 @@
     <ClCompile Include="..\..\src\burn\drv\capcom\ctv.cpp" />
     <ClCompile Include="..\..\src\burn\drv\capcom\ctv_make.cpp">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\burn\drv\capcom\d_cps1.cpp" />
     <ClCompile Include="..\..\src\burn\drv\capcom\d_cps2.cpp" />
-	<ClCompile Include="..\..\src\burn\drv\capcom\fcrash_snd.cpp" />
+    <ClCompile Include="..\..\src\burn\drv\capcom\fcrash_snd.cpp" />
     <ClCompile Include="..\..\src\burn\drv\capcom\kabuki.cpp" />
     <ClCompile Include="..\..\src\burn\drv\capcom\ps.cpp" />
     <ClCompile Include="..\..\src\burn\drv\capcom\ps_m.cpp" />
@@ -77,7 +82,7 @@
     <ClCompile Include="..\..\src\burn\drv\capcom\qs.cpp" />
     <ClCompile Include="..\..\src\burn\drv\capcom\qs_c.cpp" />
     <ClCompile Include="..\..\src\burn\drv\capcom\qs_z.cpp" />
-	<ClCompile Include="..\..\src\burn\drv\capcom\sf2mdt_snd.cpp" />
+    <ClCompile Include="..\..\src\burn\drv\capcom\sf2mdt_snd.cpp" />
     <ClCompile Include="..\..\src\burn\drv\cave\cave.cpp" />
     <ClCompile Include="..\..\src\burn\drv\cave\cave_palette.cpp" />
     <ClCompile Include="..\..\src\burn\drv\cave\cave_sprite.cpp" />
@@ -189,6 +194,11 @@
     <ClCompile Include="..\..\src\burn\drv\pgm\pgm_run.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pgm\pgm_sprite_create.cpp">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_1942.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_1943.cpp" />
@@ -196,6 +206,7 @@
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_ambush.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_arabian.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_armedf.cpp" />
+    <ClCompile Include="..\..\src\burn\drv\pre90s\d_atetris.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_aztarac.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_baraduke.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_bionicc.cpp" />
@@ -204,7 +215,9 @@
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_blueprnt.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_bombjack.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_commando.cpp" />
+    <ClCompile Include="..\..\src\burn\drv\pre90s\d_cybertnk.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_ddragon.cpp" />
+    <ClCompile Include="..\..\src\burn\drv\pre90s\d_dkong.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_dynduke.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_epos.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pre90s\d_exedexes.cpp" />
@@ -310,7 +323,7 @@
     <ClCompile Include="..\..\src\burn\drv\pst90s\d_seta2.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pst90s\d_shadfrce.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pst90s\d_silkroad.cpp" />
-	<ClCompile Include="..\..\src\burn\drv\pst90s\d_silvmil.cpp" />
+    <ClCompile Include="..\..\src\burn\drv\pst90s\d_silvmil.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pst90s\d_speedspn.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pst90s\d_suna16.cpp" />
     <ClCompile Include="..\..\src\burn\drv\pst90s\d_suprnova.cpp" />
@@ -511,9 +524,19 @@
     <ClCompile Include="..\..\src\cpu\arm7\arm7.cpp" />
     <ClCompile Include="..\..\src\cpu\arm7\arm7core.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\arm7\arm7exec.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\arm7_intf.cpp" />
     <ClCompile Include="..\..\src\cpu\arm\arm.cpp" />
@@ -521,13 +544,28 @@
     <ClCompile Include="..\..\src\cpu\h6280\h6280.cpp" />
     <ClCompile Include="..\..\src\cpu\h6280\tblh6280.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\h6280_intf.cpp" />
     <ClCompile Include="..\..\src\cpu\hd6309\6309ops.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\hd6309\6309tbl.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\hd6309\hd6309.cpp" />
     <ClCompile Include="..\..\src\cpu\hd6309_intf.cpp" />
@@ -535,46 +573,106 @@
     <ClCompile Include="..\..\src\cpu\konami\konami.cpp" />
     <ClCompile Include="..\..\src\cpu\konami\konamops.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\konami\konamtbl.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\konami_intf.cpp" />
     <ClCompile Include="..\..\src\cpu\m6502\m6502.cpp" />
     <ClCompile Include="..\..\src\cpu\m6502\t6502.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6502\t65c02.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6502\t65sc02.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6502\tdeco16.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6502\tn2a03.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6502_intf.cpp" />
     <ClCompile Include="..\..\src\cpu\m6800\6800ops.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6800\6800tbl.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6800\m6800.cpp" />
     <ClCompile Include="..\..\src\cpu\m6800_intf.cpp" />
     <ClCompile Include="..\..\src\cpu\m6805\6805ops.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6805\m6805.cpp" />
     <ClCompile Include="..\..\src\cpu\m6805_intf.cpp" />
     <ClCompile Include="..\..\src\cpu\m6809\6809ops.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6809\6809tbl.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m6809\m6809.cpp" />
     <ClCompile Include="..\..\src\cpu\m6809_intf.cpp" />
@@ -588,9 +686,19 @@
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m68k\m68kdasm.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m68k\m68kmake.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m68k\m68kopac.c">
       <CompileAs Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">CompileAsC</CompileAs>
@@ -626,30 +734,48 @@
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\m68k\m68k_in.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\nec\nec.cpp" />
     <ClCompile Include="..\..\src\cpu\nec\necinstr.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\nec\v25.cpp" />
     <ClCompile Include="..\..\src\cpu\nec\v25instr.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\nec\v25sfr.c">
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\cpu\s2650\s2650.cpp" />
     <ClCompile Include="..\..\src\cpu\s2650_intf.cpp" />
-    <ClCompile Include="..\..\src\cpu\sek.cpp" />
     <ClCompile Include="..\..\src\cpu\sh2\sh2.cpp" />
-    <ClCompile Include="..\..\src\cpu\vez.cpp" />
     <ClCompile Include="..\..\src\cpu\z80\z80.cpp" />
     <ClCompile Include="..\..\src\cpu\z80\z80daisy.cpp" />
-    <ClCompile Include="..\..\src\cpu\zet.cpp" />
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGuid>{00AAF92F-A249-4DF2-AE24-0C5427DB319E}</ProjectGuid>
     <Keyword>Xbox360Proj</Keyword>
+    <ProjectName>fba_vs2010_libretro_360</ProjectName>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'" Label="Configuration">
@@ -701,22 +827,22 @@
   </ImportGroup>
   <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">
-    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
+    <OutputFile>$(OutDir)libretro_xdk360$(TargetExt)</OutputFile>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='CodeAnalysis|Xbox 360'">
-    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
+    <OutputFile>$(OutDir)libretro_xdk360$(TargetExt)</OutputFile>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Profile|Xbox 360'">
-    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
+    <OutputFile>$(OutDir)libretro_xdk360$(TargetExt)</OutputFile>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Profile_FastCap|Xbox 360'">
-    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
+    <OutputFile>$(OutDir)libretro_xdk360$(TargetExt)</OutputFile>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">
-    <OutputFile>$(OutDir)libretro$(TargetExt)</OutputFile>
+    <OutputFile>$(OutDir)libretro_xdk360$(TargetExt)</OutputFile>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">
-    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
+    <OutputFile>$(OutDir)libretro_xdk360$(TargetExt)</OutputFile>
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Xbox 360'">
     <ClCompile>
@@ -729,9 +855,9 @@
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
       <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <PreprocessorDefinitions>_DEBUG;_XBOX;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static</PreprocessorDefinitions>
+      <PreprocessorDefinitions>_DEBUG;_XBOX;_XBOX360;_XBOX360;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static;__LIBRETRO_OPTIMIZATIONS__;FRONTEND_SUPPORTS_RGB565</PreprocessorDefinitions>
       <CallAttributedProfiling>Callcap</CallAttributedProfiling>
-      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\arm;$(SolutionDir)\..\..\src\cpu\arm7;$(SolutionDir)\..\..\src\cpu\h6280;$(SolutionDir)\..\..\src\cpu\hd6309;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\cpu\konami;$(SolutionDir)\..\..\src\cpu\m6502;$(SolutionDir)\..\..\src\cpu\m6800;$(SolutionDir)\..\..\src\cpu\m6805;$(SolutionDir)\..\..\src\cpu\m6809;$(SolutionDir)\..\..\src\cpu\m68k;$(SolutionDir)\..\..\src\cpu\nec;$(SolutionDir)\..\..\src\cpu\s2650;$(SolutionDir)\..\..\src\cpu\sh2;$(SolutionDir)\..\..\src\cpu\z80;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
       <IntrinsicFunctions>true</IntrinsicFunctions>
     </ClCompile>
     <Link>
@@ -750,9 +876,9 @@
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
       <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <PreprocessorDefinitions>_DEBUG;_XBOX;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static</PreprocessorDefinitions>
+      <PreprocessorDefinitions>_DEBUG;_XBOX;_XBOX360;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static;__LIBRETRO_OPTIMIZATIONS__;FRONTEND_SUPPORTS_RGB565</PreprocessorDefinitions>
       <CallAttributedProfiling>Callcap</CallAttributedProfiling>
-      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\arm;$(SolutionDir)\..\..\src\cpu\arm7;$(SolutionDir)\..\..\src\cpu\h6280;$(SolutionDir)\..\..\src\cpu\hd6309;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\cpu\konami;$(SolutionDir)\..\..\src\cpu\m6502;$(SolutionDir)\..\..\src\cpu\m6800;$(SolutionDir)\..\..\src\cpu\m6805;$(SolutionDir)\..\..\src\cpu\m6809;$(SolutionDir)\..\..\src\cpu\m68k;$(SolutionDir)\..\..\src\cpu\nec;$(SolutionDir)\..\..\src\cpu\s2650;$(SolutionDir)\..\..\src\cpu\sh2;$(SolutionDir)\..\..\src\cpu\z80;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
       <IntrinsicFunctions>true</IntrinsicFunctions>
     </ClCompile>
     <Link>
@@ -772,9 +898,9 @@
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <PreprocessorDefinitions>NDEBUG;_XBOX;PROFILE;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static</PreprocessorDefinitions>
+      <PreprocessorDefinitions>NDEBUG;_XBOX;_XBOX360;PROFILE;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static;__LIBRETRO_OPTIMIZATIONS__;FRONTEND_SUPPORTS_RGB565</PreprocessorDefinitions>
       <CallAttributedProfiling>Callcap</CallAttributedProfiling>
-      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\arm;$(SolutionDir)\..\..\src\cpu\arm7;$(SolutionDir)\..\..\src\cpu\h6280;$(SolutionDir)\..\..\src\cpu\hd6309;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\cpu\konami;$(SolutionDir)\..\..\src\cpu\m6502;$(SolutionDir)\..\..\src\cpu\m6800;$(SolutionDir)\..\..\src\cpu\m6805;$(SolutionDir)\..\..\src\cpu\m6809;$(SolutionDir)\..\..\src\cpu\m68k;$(SolutionDir)\..\..\src\cpu\nec;$(SolutionDir)\..\..\src\cpu\s2650;$(SolutionDir)\..\..\src\cpu\sh2;$(SolutionDir)\..\..\src\cpu\z80;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
       <IntrinsicFunctions>true</IntrinsicFunctions>
     </ClCompile>
     <Link>
@@ -798,8 +924,8 @@
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <PreprocessorDefinitions>NDEBUG;_XBOX;PROFILE;FASTCAP;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static</PreprocessorDefinitions>
-      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\arm;$(SolutionDir)\..\..\src\cpu\arm7;$(SolutionDir)\..\..\src\cpu\h6280;$(SolutionDir)\..\..\src\cpu\hd6309;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\cpu\konami;$(SolutionDir)\..\..\src\cpu\m6502;$(SolutionDir)\..\..\src\cpu\m6800;$(SolutionDir)\..\..\src\cpu\m6805;$(SolutionDir)\..\..\src\cpu\m6809;$(SolutionDir)\..\..\src\cpu\m68k;$(SolutionDir)\..\..\src\cpu\nec;$(SolutionDir)\..\..\src\cpu\s2650;$(SolutionDir)\..\..\src\cpu\sh2;$(SolutionDir)\..\..\src\cpu\z80;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>NDEBUG;_XBOX;_XBOX360;PROFILE;FASTCAP;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static;__LIBRETRO_OPTIMIZATIONS__;FRONTEND_SUPPORTS_RGB565</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
       <IntrinsicFunctions>true</IntrinsicFunctions>
     </ClCompile>
     <Link>
@@ -821,8 +947,8 @@
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <PreprocessorDefinitions>NDEBUG;_XBOX;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static</PreprocessorDefinitions>
-      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\arm;$(SolutionDir)\..\..\src\cpu\arm7;$(SolutionDir)\..\..\src\cpu\h6280;$(SolutionDir)\..\..\src\cpu\hd6309;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\cpu\konami;$(SolutionDir)\..\..\src\cpu\m6502;$(SolutionDir)\..\..\src\cpu\m6800;$(SolutionDir)\..\..\src\cpu\m6805;$(SolutionDir)\..\..\src\cpu\m6809;$(SolutionDir)\..\..\src\cpu\m68k;$(SolutionDir)\..\..\src\cpu\nec;$(SolutionDir)\..\..\src\cpu\s2650;$(SolutionDir)\..\..\src\cpu\sh2;$(SolutionDir)\..\..\src\cpu\z80;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>NDEBUG;_XBOX;_XBOX360;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static;__LIBRETRO_OPTIMIZATIONS__;FRONTEND_SUPPORTS_RGB565</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd;$(SolutionDir)\..\..\src\dep\generated</AdditionalIncludeDirectories>
       <IntrinsicFunctions>true</IntrinsicFunctions>
       <PreschedulingOptimization>true</PreschedulingOptimization>
     </ClCompile>
@@ -845,8 +971,8 @@
       <BufferSecurityCheck>false</BufferSecurityCheck>
       <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <PreprocessorDefinitions>NDEBUG;_XBOX;LTCG;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static</PreprocessorDefinitions>
-      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\arm;$(SolutionDir)\..\..\src\cpu\arm7;$(SolutionDir)\..\..\src\cpu\h6280;$(SolutionDir)\..\..\src\cpu\hd6309;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\cpu\konami;$(SolutionDir)\..\..\src\cpu\m6502;$(SolutionDir)\..\..\src\cpu\m6800;$(SolutionDir)\..\..\src\cpu\m6805;$(SolutionDir)\..\..\src\cpu\m6809;$(SolutionDir)\..\..\src\cpu\m68k;$(SolutionDir)\..\..\src\cpu\nec;$(SolutionDir)\..\..\src\cpu\s2650;$(SolutionDir)\..\..\src\cpu\sh2;$(SolutionDir)\..\..\src\cpu\z80;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\dep\libs\zlib;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>NDEBUG;_XBOX;_XBOX360;LTCG;_LIB;%(PreprocessorDefinitions);USE_SPEEDHACKS;__LIBRETRO__;INLINE=__inline static;EXTERNAL_ZLIB;__fastcall=;MAME_INLINE=_inline static;__LIBRETRO_OPTIMIZATIONS__;FRONTEND_SUPPORTS_RGB565</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)\..\..\src\burn\drv\taito;$(SolutionDir)\..\..\src\dep\generated;$(SolutionDir)\..\..\src\burner\libretro;$(SolutionDir)\..\..\src\burner;$(SolutionDir)\..\..\src\burn;$(SolutionDir)\..\..\src\burn\drv\pgm;$(SolutionDir)\..\..\src\burn\devices;$(SolutionDir)\..\..\src\burn\snd;$(SolutionDir)\..\..\src\cpu\;$(SolutionDir)\..\..\src\cpu\i8039;$(SolutionDir)\..\..\src\intf\input;$(SolutionDir)\..\..\src\intf;$(SolutionDir)\..\..\src\intf\cd</AdditionalIncludeDirectories>
       <IntrinsicFunctions>true</IntrinsicFunctions>
     </ClCompile>
     <Link>
@@ -858,4 +984,4 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
Index: projectfiles/visualstudio-2010-libretro-360/fba_vs2010_libretro_360.vcxproj.filters
===================================================================
--- projectfiles/visualstudio-2010-libretro-360/fba_vs2010_libretro_360.vcxproj.filters	(revision 847)
+++ projectfiles/visualstudio-2010-libretro-360/fba_vs2010_libretro_360.vcxproj.filters	(working copy)
@@ -126,7 +126,7 @@
     <Filter Include="Source Files\burn\snd">
       <UniqueIdentifier>{aa239b2a-4448-46ed-aa06-51a84303473a}</UniqueIdentifier>
     </Filter>
-	<Filter Include="Source Files\burner\libretro">
+    <Filter Include="Source Files\burner\libretro">
       <UniqueIdentifier>{7f4ef354-8a73-47f9-9c04-9924b98358ff}</UniqueIdentifier>
     </Filter>
   </ItemGroup>
@@ -1367,9 +1367,6 @@
     <ClCompile Include="..\..\src\cpu\m6502\tn2a03.c">
       <Filter>Source Files\cpu\m6502</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\src\cpu\zet.cpp">
-      <Filter>Source Files\cpu</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\src\cpu\arm7_intf.cpp">
       <Filter>Source Files\cpu</Filter>
     </ClCompile>
@@ -1400,12 +1397,6 @@
     <ClCompile Include="..\..\src\cpu\s2650_intf.cpp">
       <Filter>Source Files\cpu</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\src\cpu\sek.cpp">
-      <Filter>Source Files\cpu</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\src\cpu\vez.cpp">
-      <Filter>Source Files\cpu</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\src\burn\vector.cpp">
       <Filter>Source Files\burn</Filter>
     </ClCompile>
@@ -1571,7 +1562,7 @@
     <ClCompile Include="..\..\src\cpu\m68k\m68kopnz.c">
       <Filter>Source Files\cpu\m68k</Filter>
     </ClCompile>
-	<ClCompile Include="..\..\src\burner\libretro\neocdlist.cpp">
+    <ClCompile Include="..\..\src\burner\libretro\neocdlist.cpp">
       <Filter>Source Files\burner\libretro</Filter>
     </ClCompile>
     <ClCompile Include="..\..\src\burner\libretro\libretro.cpp">
@@ -1586,5 +1577,14 @@
     <ClCompile Include="..\..\src\burn\drv\pst90s\d_silvmil.cpp">
       <Filter>Source Files\burn\drv\pst90s</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\burn\drv\pre90s\d_atetris.cpp">
+      <Filter>Source Files\burn\drv\pre90s</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\burn\drv\pre90s\d_cybertnk.cpp">
+      <Filter>Source Files\burn\drv\pre90s</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\burn\drv\pre90s\d_dkong.cpp">
+      <Filter>Source Files\burn\drv\pre90s</Filter>
+    </ClCompile>
   </ItemGroup>
 </Project>
\ No newline at end of file
Index: src/burn/burn_gun.cpp
===================================================================
--- src/burn/burn_gun.cpp	(revision 847)
+++ src/burn/burn_gun.cpp	(working copy)
@@ -155,10 +155,17 @@
 	UINT8* pTile = pBurnDraw + nBurnGunMaxX * nBurnBpp * (y - 1) + nBurnBpp * x;
 	
 	UINT32 nTargetCol = 0;
+#ifdef __LIBRETRO__
+	if (num == 0) nTargetCol = BurnHighCol(0xfc, 0x12, 0xee, 0);
+	if (num == 1) nTargetCol = BurnHighCol(0x1c, 0xfc, 0x1c, 0);
+	if (num == 2) nTargetCol = BurnHighCol(0x15, 0x93, 0xfd, 0);
+	if (num == 3) nTargetCol = BurnHighCol(0xf7, 0xfa, 0x0e, 0);
+#else
 	if (num == 0) nTargetCol = BurnHighCol(P1Colour, 0);
 	if (num == 1) nTargetCol = BurnHighCol(P2Colour, 0);
 	if (num == 2) nTargetCol = BurnHighCol(P3Colour, 0);
 	if (num == 3) nTargetCol = BurnHighCol(P4Colour, 0);
+#endif
 
 	for (INT32 y2 = 0; y2 < 17; y2++) {
 
Index: src/burn/drv/neogeo/d_neogeo.cpp
===================================================================
--- src/burn/drv/neogeo/d_neogeo.cpp	(revision 847)
+++ src/burn/drv/neogeo/d_neogeo.cpp	(working copy)
@@ -932,7 +932,7 @@
 	{ "",                  0x00000, 0x00000000, 0                                                   }, // 12
 #endif
 	{ "sp-1v1_3db8c.bin",  0x20000, 0x162f0ebe, BRF_ESS | BRF_PRG | BRF_BIOS | BRF_SELECT | BRF_OPT }, // 13 Deck ver. 6 (Git Ver 1.3)
-#if !defined (ROM_VERIFY)
+#if !defined (ROM_VERIFY) && !defined(__LIBRETRO__)
 	{ "uni-bios_3_0.rom",  0x20000, 0xa97c89a9, BRF_ESS | BRF_PRG | BRF_BIOS | BRF_SELECT | BRF_OPT }, // 14 Universe BIOS ver. 3.0 (free)
 //	{ "uni-bios_3_0.rom",  0x20000, 0x4cd01e5f, BRF_ESS | BRF_PRG | BRF_BIOS | BRF_SELECT | BRF_OPT }, // 14 Universe BIOS ver. 3.0 (full)
 #else
Index: src/burn/drv/pst90s/d_suprnova.cpp
===================================================================
--- src/burn/drv/pst90s/d_suprnova.cpp	(revision 847)
+++ src/burn/drv/pst90s/d_suprnova.cpp	(working copy)
@@ -1,5 +1,5 @@
 #include "tiles_generic.h"
-#include "sh2.h"
+#include "sh2_intf.h"
 
 static UINT8 DrvInputPort0[8] = {0, 0, 0, 0, 0, 0, 0, 0};
 static UINT8 DrvInputPort1[8] = {0, 0, 0, 0, 0, 0, 0, 0};
Index: src/burner/libretro/burn_libretro_opts.h
===================================================================
--- src/burner/libretro/burn_libretro_opts.h	(revision 847)
+++ src/burner/libretro/burn_libretro_opts.h	(working copy)
@@ -1,6 +1,14 @@
 #ifndef _LIBRETRO_OPTIMIZATIONS_H_
 #define _LIBRETRO_OPTIMIZATIONS_H_
 
-#define LIBRETRO_COLOR_15BPP_BGR(color) ((((color & 0x1f) << 10) | (((color & 0x3e0) >> 5) << 5) | (((color & 0x7c00) >> 10))) & 0x7fff)
+#define BurnHighCol LIBRETRO_COLOR_CONVERT
 
+#ifdef FRONTEND_SUPPORTS_RGB565
+#define LIBRETRO_COLOR_15BPP_XBGR(color, unused) (((color & 0x001f) << 11) | ((color & 0x03e0) << 1) | ((color & 0x7c00) >> 10))
+#define LIBRETRO_COLOR_CONVERT(r, g, b, a) (((r << 8) & 0xf800) | ((g << 3) & 0x07e0) | ((b >> 3) & 0x001f))
+#else
+#define LIBRETRO_COLOR_15BPP_XBGR(color, unused) ((((color & 0x1f) << 10) | (((color & 0x3e0) >> 5) << 5) | (((color & 0x7c00) >> 10))) & 0x7fff)
+#define LIBRETRO_COLOR_CONVERT(r, g, b, a) (((r << 7) & 0x7c00) | ((g << 2) & 0x03e0) | ((b >> 3) & 0x001f))
 #endif
+
+#endif
Index: src/burner/libretro/burner_libretro.h
===================================================================
--- src/burner/libretro/burner_libretro.h	(revision 847)
+++ src/burner/libretro/burner_libretro.h	(working copy)
@@ -2,7 +2,7 @@
 #define _BURNER_LIBRETRO_H
 
 #include "gameinp.h"
-#include "inp_keys.h"
+#include "input/inp_keys.h"
 
 extern int bDrvOkay;
 extern int bRunPause;
Index: src/burner/libretro/libretro.cpp
===================================================================
--- src/burner/libretro/libretro.cpp	(revision 847)
+++ src/burner/libretro/libretro.cpp	(working copy)
@@ -1,6 +1,6 @@
 #include "libretro.h"
 #include "burner.h"
-#include "inp_keys.h"
+#include "input/inp_keys.h"
 #include "state.h"
 #include <string.h>
 #include <stdio.h>
@@ -9,7 +9,7 @@
 #include <string>
 #include <ctype.h>
 
-#include "cd_interface.h"
+#include "cd/cd_interface.h"
 
 static unsigned int BurnDrvGetIndexByName(const char* name);
 
@@ -52,14 +52,15 @@
 void retro_set_environment(retro_environment_t cb) { environ_cb = cb; }
 
 static char g_rom_dir[1024];
+static bool driver_inited;
 
 void retro_get_system_info(struct retro_system_info *info)
 {
    info->library_name = "FB Alpha";
-   info->library_version = "0.2.97.26";
+   info->library_version = "v0.2.97.27";
    info->need_fullpath = true;
    info->block_extract = true;
-   info->valid_extensions = "zip|ZIP";
+   info->valid_extensions = "iso|ISO|zip|ZIP";
 }
 
 /////
@@ -319,7 +320,9 @@
 
 void retro_deinit()
 {
-   BurnDrvExit();
+   if (driver_inited)
+      BurnDrvExit();
+   driver_inited = false;
    BurnLibExit();
 }
 
@@ -332,13 +335,14 @@
    BurnDrvGetVisibleSize(&width, &height);
    pBurnDraw = (uint8_t*)g_fba_frame;
 
+   poll_input();
+
    nBurnLayer = 0xff;
    pBurnSoundOut = g_audio_buf;
    nBurnSoundRate = 32000;
    nBurnSoundLen = AUDIO_SEGMENT_LENGTH;
    nCurrentFrame++;
 
-   poll_input();
 
    BurnDrvFrame();
    unsigned drv_flags = BurnDrvGetFlags();
@@ -424,7 +428,7 @@
    int maximum = width > height ? width : height;
    struct retro_game_geometry geom = { width, height, maximum, maximum };
 
-   struct retro_system_timing timing = { 60.0, 32000.0 };
+   struct retro_system_timing timing = { 60.0, 60.0 * AUDIO_SEGMENT_LENGTH };
 
    info->geometry = geom;
    info->timing   = timing;
@@ -450,17 +454,41 @@
    else
       nBurnPitch = width * sizeof(uint16_t);
 
+   unsigned rotation;
+   switch (drv_flags & (BDF_ORIENTATION_FLIPPED | BDF_ORIENTATION_VERTICAL))
+   {
+      case BDF_ORIENTATION_VERTICAL:
+         rotation = 1;
+         break;
+
+      case BDF_ORIENTATION_FLIPPED:
+         rotation = 2;
+         break;
+
+      case BDF_ORIENTATION_VERTICAL | BDF_ORIENTATION_FLIPPED:
+         rotation = 3;
+         break;
+
+      default:
+         rotation = 0;
+   }
+
+   environ_cb(RETRO_ENVIRONMENT_SET_ROTATION, &rotation);
+
    return true;
 }
 
+#if defined(FRONTEND_SUPPORTS_RGB565)
+static unsigned int HighCol16(int r, int g, int b, int  /* i */)
+{
+   return (((r << 8) & 0xf800) | ((g << 3) & 0x07e0) | ((b >> 3) & 0x001f));
+}
+#else
 static unsigned int HighCol15(int r, int g, int b, int  /* i */)
 {
-   unsigned int t = 0;
-   t |= (r << 7) & 0x7c00;
-   t |= (g << 2) & 0x03e0;
-   t |= (b >> 3) & 0x001f;
-   return t;
+   return (((r << 7) & 0x7c00) | ((g << 2) & 0x03e0) | ((b >> 3) & 0x001f));
 }
+#endif
 
 int VidRecalcPal()
 {
@@ -471,7 +499,13 @@
 {
    nBurnBpp = 2;
    VidRecalcPal();
+#if 0
+#ifdef FRONTEND_SUPPORTS_RGB565
+   BurnHighCol = HighCol16;
+#else
    BurnHighCol = HighCol15;
+#endif
+#endif
 }
 
 static void init_audio()
@@ -515,8 +549,11 @@
       buf[0] = '\0';
 }
 
+bool analog_controls_enabled = false;
+
 bool retro_load_game(const struct retro_game_info *info)
 {
+   bool retval = false;
    char basename[128];
    extract_basename(basename, info->path, sizeof(basename));
    extract_directory(g_rom_dir, info->path, sizeof(g_rom_dir));
@@ -530,15 +567,21 @@
       if (!fba_init(i))
          return false;
 
-      init_input();
+      driver_inited = true;
+      analog_controls_enabled = init_input();
 
-      return true;
+      retval = true;
    }
    else
-   {
       fprintf(stderr, "[FBA] Cannot find driver.\n");
-      return false;
-   }
+
+#ifdef FRONTEND_SUPPORTS_RGB565
+   enum retro_pixel_format fmt = RETRO_PIXEL_FORMAT_RGB565;
+   if(environ_cb(RETRO_ENVIRONMENT_SET_PIXEL_FORMAT, &fmt)) 
+      fprintf(stderr, "Frontend supports RGB565 - will use that instead of XRGB1555.\n");
+#endif
+
+   return retval;
 }
 
 bool retro_load_game_special(unsigned, const struct retro_game_info*, size_t) { return false; }
@@ -557,65 +600,18 @@
 // Input stuff.
 
 // Ref GamcPlayer() in ../gamc.cpp
-#define P1_COIN	FBK_5
-#define P1_START  FBK_1
-#define P1_LEFT   FBK_LEFTARROW
-#define P1_RIGHT  FBK_RIGHTARROW
-#define P1_UP     FBK_UPARROW
-#define P1_DOWN   FBK_DOWNARROW
-#define P1_FIRE1  FBK_A
-#define P1_FIRE2  FBK_S
-#define P1_FIRE3  FBK_D
-#define P1_FIRE4  FBK_Z
-#define P1_FIRE5  FBK_X
-#define P1_FIRE6  FBK_C
-#define P1_FIRED  FBK_V
-#define P1_SERVICE FBK_F2
-
-#define P2_COIN 0x07
-#define P2_START 0x03
-#define P2_LEFT 0x4000
-#define P2_RIGHT 0x4001
-#define P2_UP 0x4002
-#define P2_DOWN 0x4003
-#define P2_FIRE1 0x4080
-#define P2_FIRE2 0x4081
-#define P2_FIRE3 0x4082
-#define P2_FIRE4 0x4083
-#define P2_FIRE5 0x4084
-#define P2_FIRE6 0x4085
-#define P2_FIRED 0x4086
-
-#define P3_COIN 0x08
-#define P3_START 0x04
-#define P3_LEFT 0x4100
-#define P3_RIGHT 0x4101
-#define P3_UP 0x4102
-#define P3_DOWN 0x4103
-#define P3_FIRE1 0x4180
-#define P3_FIRE2 0x4181
-#define P3_FIRE3 0x4182
-#define P3_FIRE4 0x4183
-#define P3_FIRE5 0x4184
-#define P3_FIRE6 0x4185
-
-#define P4_COIN 0x09
-#define P4_START 0x05
-#define P4_LEFT 0x4200
-#define P4_RIGHT 0x4201
-#define P4_UP 0x4202
-#define P4_DOWN 0x4203
-#define P4_FIRE1 0x4280
-#define P4_FIRE2 0x4281
-#define P4_FIRE3 0x4282
-#define P4_FIRE4 0x4283
-#define P4_FIRE5 0x4284
-#define P4_FIRE6 0x4285
-
-static unsigned char keybinds[0x5000][2]; 
+struct key_map
+{
+   const char *bii_name;
+   unsigned nCode[2];
+};
+static uint8_t keybinds[0x5000][2]; 
 #define _BIND(x) RETRO_DEVICE_ID_JOYPAD_##x
 #define RESET_BIND 12
 #define SERVICE_BIND 13
+
+#define BIND_MAP_COUNT 145
+
 static bool init_input()
 {
    GameInpInit();
@@ -633,179 +629,750 @@
    }
 
    //needed for Neo Geo button mappings (and other drivers in future)
-   const char * boardrom = BurnDrvGetTextA(DRV_BOARDROM);
+   const char * parentrom	= BurnDrvGetTextA(DRV_PARENT);
+   const char * boardrom	= BurnDrvGetTextA(DRV_BOARDROM);
+   const char * drvname		= BurnDrvGetTextA(DRV_NAME);
+   INT32	genre		= BurnDrvGetGenreFlags();
+   INT32	hardware	= BurnDrvGetHardwareCode();
 
+   fprintf(stderr, "has_analog: %d\n", has_analog);
+   fprintf(stderr, "parentrom: %s\n", parentrom);
+   fprintf(stderr, "boardrom: %s\n", boardrom);
+   fprintf(stderr, "drvname: %s\n", drvname);
+   fprintf(stderr, "genre: %d\n", genre);
+   fprintf(stderr, "hardware: %d\n", hardware);
+
+   /* initialization */
+   struct BurnInputInfo bii;
+   memset(&bii, 0, sizeof(bii));
+
    // Bind to nothing.
    for (unsigned i = 0; i < 0x5000; i++)
       keybinds[i][0] = 0xff;
 
+   pgi = GameInp;
+
+   key_map bind_map[BIND_MAP_COUNT];
+
+   bind_map[0].bii_name = "P1 Coin";
+   bind_map[0].nCode[0] = _BIND(SELECT);
+   bind_map[0].nCode[1] = 0;
+
+   bind_map[1].bii_name = "P1 Start";
+   bind_map[1].nCode[0] = _BIND(START);
+   bind_map[1].nCode[1] = 0;
+
+   bind_map[2].bii_name = "Start 1";
+   bind_map[2].nCode[0] = _BIND(START);
+   bind_map[2].nCode[1] = 0;
+
+   bind_map[3].bii_name = "P1 Up";
+   bind_map[3].nCode[0] = _BIND(UP);
+   bind_map[3].nCode[1] = 0;
+
+   bind_map[4].bii_name = "P1 Down";
+   bind_map[4].nCode[0] = _BIND(DOWN);
+   bind_map[4].nCode[1] = 0;
+
+   bind_map[5].bii_name = "P1 Left";
+   bind_map[5].nCode[0] = _BIND(LEFT);
+   bind_map[5].nCode[1] = 0;
+
+   bind_map[6].bii_name = "P1 Right";
+   bind_map[6].nCode[0] = _BIND(RIGHT);
+   bind_map[6].nCode[1] = 0;
+
+   bind_map[7].bii_name = "P1 Attack";
+   bind_map[7].nCode[0] = _BIND(Y);
+   bind_map[7].nCode[1] = 0;
+
+   bind_map[8].bii_name = "Accelerate";
+   bind_map[8].nCode[0] = _BIND(B);
+   bind_map[8].nCode[1] = 0;
+
+   bind_map[9].bii_name = "Brake";
+   bind_map[9].nCode[0] = _BIND(Y);
+   bind_map[9].nCode[1] = 0;
+
+   bind_map[10].bii_name = "Gear";
+   bind_map[10].nCode[0] = _BIND(A);
+   bind_map[10].nCode[1] = 0;
+
+   /* for Forgotten Worlds, etc */
+   bind_map[11].bii_name = "P1 Turn";
+   bind_map[11].nCode[0] = _BIND(A);
+   bind_map[11].nCode[1] = 0;
+
+   bind_map[12].bii_name = "P1 Jump";
+   bind_map[12].nCode[0] = _BIND(B);
+   bind_map[12].nCode[1] = 0;
+
+   bind_map[13].bii_name = "P1 Pin";
+   bind_map[13].nCode[0] = _BIND(A);
+   bind_map[13].nCode[1] = 0;
+
+   bind_map[14].bii_name = "P1 Select";
+   bind_map[14].nCode[0] = _BIND(A);
+   bind_map[14].nCode[1] = 0;
+
+   bind_map[15].bii_name = "P1 Use";
+   bind_map[15].nCode[0] = _BIND(X);
+   bind_map[15].nCode[1] = 0;
+
+   bind_map[16].bii_name = "P1 Weak Punch";
+   bind_map[16].nCode[0] = _BIND(Y);
+   bind_map[16].nCode[1] = 0;
+
+   bind_map[17].bii_name = "P1 Medium Punch";
+   bind_map[17].nCode[0] = _BIND(X);
+   bind_map[17].nCode[1] = 0;
+
+   bind_map[18].bii_name = "P1 Strong Punch";
+   bind_map[18].nCode[0] = _BIND(L);
+   bind_map[18].nCode[1] = 0;
+
+   bind_map[19].bii_name = "P1 Weak Kick";
+   bind_map[19].nCode[0] = _BIND(B);
+   bind_map[19].nCode[1] = 0;
+
+   bind_map[20].bii_name = "P1 Medium Kick";
+   bind_map[20].nCode[0] = _BIND(A);
+   bind_map[20].nCode[1] = 0;
+
+   bind_map[21].bii_name = "P1 Strong Kick";
+   bind_map[21].nCode[0] = _BIND(R);
+   bind_map[21].nCode[1] = 0;
+
+   bind_map[22].bii_name = "P1 Rotate Left";
+   bind_map[22].nCode[0] = _BIND(B);
+   bind_map[22].nCode[1] = 0;
+
+   bind_map[23].bii_name = "P1 Rotate Right";
+   bind_map[23].nCode[0] = _BIND(A);
+   bind_map[23].nCode[1] = 0;
+
+   bind_map[24].bii_name = "P1 Punch";
+   bind_map[24].nCode[0] = _BIND(Y);
+   bind_map[24].nCode[1] = 0;
+
+   bind_map[25].bii_name = "P1 Kick";
+   bind_map[25].nCode[0] = _BIND(B);
+   bind_map[25].nCode[1] = 0;
+
+   bind_map[26].bii_name = "P1 Special";
+   bind_map[26].nCode[0] = _BIND(A);
+   bind_map[26].nCode[1] = 0;
+
+   bind_map[27].bii_name = "P1 Shot";
+   bind_map[27].nCode[0] = _BIND(B);
+   bind_map[27].nCode[1] = 0;
+
+   bind_map[28].bii_name = "P1 Shot (auto)";
+   bind_map[28].nCode[0] = _BIND(X);
+   bind_map[28].nCode[1] = 0;
+
+   /* Simpsons - Konami */
+   bind_map[29].bii_name = "P1 Button 1";
+   bind_map[29].nCode[0] = _BIND(Y);
+   bind_map[29].nCode[1] = 0;
+
+   /* Simpsons - Konami */
+   bind_map[30].bii_name = "P1 Button 2";
+   bind_map[30].nCode[0] = _BIND(B);
+   bind_map[30].nCode[1] = 0;
+
+   bind_map[31].bii_name = "P1 Button 3";
+   bind_map[31].nCode[0] = _BIND(A);
+   bind_map[31].nCode[1] = 0;
+
+   bind_map[32].bii_name = "P1 Button 4";
+   bind_map[32].nCode[0] = _BIND(X);
+   bind_map[32].nCode[1] = 0;
+
+   /* Progear */
+   bind_map[33].bii_name = "P1 Auto";
+   bind_map[33].nCode[0] = _BIND(A);
+   bind_map[33].nCode[1] = 0;
+
+   /* Punisher */
+   bind_map[34].bii_name = "P1 Super";
+   bind_map[34].nCode[0] = _BIND(A);
+   bind_map[34].nCode[1] = 0;
+
+   bind_map[35].bii_name = "P1 Answer 1";
+   bind_map[35].nCode[0] = _BIND(Y);
+   bind_map[35].nCode[1] = 0;
+
+   bind_map[36].bii_name = "P1 Answer 2";
+   bind_map[36].nCode[0] = _BIND(X);
+   bind_map[36].nCode[1] = 0;
+
+   bind_map[37].bii_name = "P1 Answer 3";
+   bind_map[37].nCode[0] = _BIND(B);
+   bind_map[37].nCode[1] = 0;
+
+   bind_map[38].bii_name = "P1 Answer 4";
+   bind_map[38].nCode[0] = _BIND(A);
+   bind_map[38].nCode[1] = 0;
+
+   bind_map[39].bii_name = "P1 Shot 1";
+   bind_map[39].nCode[0] = _BIND(B);
+   bind_map[39].nCode[1] = 0;
+
+   /* Pang 3 */
+   bind_map[40].bii_name = "P1 Shot 1";
+   bind_map[40].nCode[0] = _BIND(B);
+   bind_map[40].nCode[1] = 0;
+
+   /* Pang 3 */
+   bind_map[41].bii_name = "P1 Shot 2";
+   bind_map[41].nCode[0] = _BIND(A);
+   bind_map[41].nCode[1] = 0;
+
+   bind_map[42].bii_name = "P1 Bomb";
+   bind_map[42].nCode[0] = _BIND(A);
+   bind_map[42].nCode[1] = 0;
+
+   bind_map[43].bii_name = "P1 Special";
+   bind_map[43].nCode[0] = _BIND(A);
+   bind_map[43].nCode[1] = 0;
+
+   /* for Ghouls 'n Ghosts */
+   bind_map[44].bii_name = "P1 Fire";
+   bind_map[44].nCode[0] = _BIND(Y);
+   bind_map[44].nCode[1] = 0;
+
+   /* TMNT */
+   bind_map[45].bii_name = "P1 Fire 1";
+   bind_map[45].nCode[0] = _BIND(Y);
+   bind_map[45].nCode[1] = 0;
+
+   /* Space Harrier */
+   bind_map[46].bii_name = "Fire 1";
+   bind_map[46].nCode[0] = _BIND(Y);
+   bind_map[46].nCode[1] = 0;
+
+   /* Space Harrier */
+   bind_map[47].bii_name = "Fire 2";
+   bind_map[47].nCode[0] = _BIND(B);
+   bind_map[47].nCode[1] = 0;
+
+   /* Space Harrier */
+   bind_map[48].bii_name = "Fire 3";
+   bind_map[48].nCode[0] = _BIND(A);
+   bind_map[48].nCode[1] = 0;
+
+   /* TMNT */
+   bind_map[49].bii_name = "P1 Fire 2";
+   bind_map[49].nCode[0] = _BIND(B);
+   bind_map[49].nCode[1] = 0;
+
+   /* Strider */
+   bind_map[50].bii_name = "P1 Fire 3";
+   bind_map[50].nCode[0] = _BIND(A);
+   bind_map[50].nCode[1] = 0;
+
+   /* Strider */
+   bind_map[51].bii_name = "Coin 1";
+   bind_map[51].nCode[0] = _BIND(SELECT);
+   bind_map[51].nCode[1] = 0;
+
+   /* Neo Geo */
+   bind_map[52].bii_name = "P1 Button A";
+   bind_map[52].nCode[0] = _BIND(B);
+   bind_map[52].nCode[1] = 0;
+
+   /* Neo Geo */
+   bind_map[53].bii_name = "P1 Button B";
+   bind_map[53].nCode[0] = _BIND(A);
+   bind_map[53].nCode[1] = 0;
+
+   /* Neo Geo */
+   bind_map[54].bii_name = "P1 Button C";
+   bind_map[54].nCode[0] = _BIND(Y);
+   bind_map[54].nCode[1] = 0;
+
+   /* Neo Geo */
+   bind_map[55].bii_name = "P1 Button D";
+   bind_map[55].nCode[0] = _BIND(X);
+   bind_map[55].nCode[1] = 0;
+
+   bind_map[56].bii_name = "P2 Coin";
+   bind_map[56].nCode[0] = _BIND(SELECT);
+   bind_map[56].nCode[1] = 1;
+
+   bind_map[57].bii_name = "P2 Start";
+   bind_map[57].nCode[0] = _BIND(START);
+   bind_map[57].nCode[1] = 1;
+
+   bind_map[58].bii_name = "P2 Up";
+   bind_map[58].nCode[0] = _BIND(UP);
+   bind_map[58].nCode[1] = 1;
+
+   bind_map[59].bii_name = "P2 Down";
+   bind_map[59].nCode[0] = _BIND(DOWN);
+   bind_map[59].nCode[1] = 1;
+
+   bind_map[60].bii_name = "P2 Left";
+   bind_map[60].nCode[0] = _BIND(LEFT);
+   bind_map[60].nCode[1] = 1;
+
+   bind_map[61].bii_name = "P2 Right";
+   bind_map[61].nCode[0] = _BIND(RIGHT);
+   bind_map[61].nCode[1] = 1;
+
+   bind_map[62].bii_name = "P2 Attack";
+   bind_map[62].nCode[0] = _BIND(Y);
+   bind_map[62].nCode[1] = 1;
+
+   // for Forgotten Worlds, etc.
+   bind_map[63].bii_name = "P2 Turn";
+   bind_map[63].nCode[0] = _BIND(A);
+   bind_map[63].nCode[1] = 1;
+
+   bind_map[64].bii_name = "P2 Jump";
+   bind_map[64].nCode[0] = _BIND(B);
+   bind_map[64].nCode[1] = 1;
+
+   bind_map[65].bii_name = "P2 Pin";
+   bind_map[65].nCode[0] = _BIND(A);
+   bind_map[65].nCode[1] = 1;
+
+   bind_map[66].bii_name = "P2 Select";
+   bind_map[66].nCode[0] = _BIND(A);
+   bind_map[66].nCode[1] = 1;
+
+   bind_map[67].bii_name = "P2 Use";
+   bind_map[67].nCode[0] = _BIND(X);
+   bind_map[67].nCode[1] = 1;
+
+   bind_map[68].bii_name = "P2 Weak Punch";
+   bind_map[68].nCode[0] = _BIND(Y);
+   bind_map[68].nCode[1] = 1;
+
+   bind_map[69].bii_name = "P2 Medium Punch";
+   bind_map[69].nCode[0] = _BIND(X);
+   bind_map[69].nCode[1] = 1;
+
+   bind_map[70].bii_name = "P2 Strong Punch";
+   bind_map[70].nCode[0] = _BIND(L);
+   bind_map[70].nCode[1] = 1;
+
+   bind_map[71].bii_name = "P2 Weak Kick";
+   bind_map[71].nCode[0] = _BIND(B);
+   bind_map[71].nCode[1] = 1;
+
+   bind_map[72].bii_name = "P2 Medium Kick";
+   bind_map[72].nCode[0] = _BIND(A);
+   bind_map[72].nCode[1] = 1;
+
+   bind_map[73].bii_name = "P2 Strong Kick";
+   bind_map[73].nCode[0] = _BIND(R);
+   bind_map[73].nCode[1] = 1;
+
+   bind_map[74].bii_name = "P2 Rotate Left";
+   bind_map[74].nCode[0] = _BIND(B);
+   bind_map[74].nCode[1] = 1;
+
+   bind_map[75].bii_name = "P2 Rotate Right";
+   bind_map[75].nCode[0] = _BIND(A);
+   bind_map[75].nCode[1] = 1;
+
+   bind_map[76].bii_name = "P2 Punch";
+   bind_map[76].nCode[0] = _BIND(Y);
+   bind_map[76].nCode[1] = 1;
+
+   bind_map[77].bii_name = "P2 Kick";
+   bind_map[77].nCode[0] = _BIND(B);
+   bind_map[77].nCode[1] = 1;
+
+   bind_map[78].bii_name = "P2 Special";
+   bind_map[78].nCode[0] = _BIND(A);
+   bind_map[78].nCode[1] = 1;
+
+   bind_map[79].bii_name = "P2 Shot";
+   bind_map[79].nCode[0] = _BIND(B);
+   bind_map[79].nCode[1] = 1;
+
+   /* Simpsons - Konami */
+   bind_map[80].bii_name = "P2 Button 1";
+   bind_map[80].nCode[0] = _BIND(Y);
+   bind_map[80].nCode[1] = 1;
+
+   bind_map[81].bii_name = "P2 Button 2";
+   bind_map[81].nCode[0] = _BIND(B);
+   bind_map[81].nCode[1] = 1;
+
+   /* Various */
+   bind_map[82].bii_name = "P2 Button 3";
+   bind_map[82].nCode[0] = _BIND(A);
+   bind_map[82].nCode[1] = 1;
+
+   bind_map[83].bii_name = "P2 Button 4";
+   bind_map[83].nCode[0] = _BIND(X);
+   bind_map[83].nCode[1] = 1;
+
+   /* Progear */
+   bind_map[84].bii_name = "P2 Auto";
+   bind_map[84].nCode[0] = _BIND(A);
+   bind_map[84].nCode[1] = 1;
+
+   bind_map[85].bii_name = "P2 Shot (auto)";
+   bind_map[85].nCode[0] = _BIND(X);
+   bind_map[85].nCode[1] = 1;
+
+   /* Punisher */
+   bind_map[86].bii_name = "P2 Super";
+   bind_map[86].nCode[0] = _BIND(A);
+   bind_map[86].nCode[1] = 1;
+
+   bind_map[87].bii_name = "P2 Answer 1";
+   bind_map[87].nCode[0] = _BIND(Y);
+   bind_map[87].nCode[1] = 1;
+
+   bind_map[88].bii_name = "P2 Answer 2";
+   bind_map[88].nCode[0] = _BIND(X);
+   bind_map[88].nCode[1] = 1;
+
+   bind_map[89].bii_name = "P2 Answer 3";
+   bind_map[89].nCode[0] = _BIND(B);
+   bind_map[89].nCode[1] = 1;
+
+   bind_map[90].bii_name = "P2 Answer 4";
+   bind_map[90].nCode[0] = _BIND(A);
+   bind_map[90].nCode[1] = 1;
+
+   /* Pang 3 */
+   bind_map[91].bii_name = "P2 Shot 1";
+   bind_map[91].nCode[0] = _BIND(B);
+   bind_map[91].nCode[1] = 1;
+
+   bind_map[92].bii_name = "P2 Shot 2";
+   bind_map[92].nCode[0] = _BIND(A);
+   bind_map[92].nCode[1] = 1;
+
+   bind_map[93].bii_name = "P2 Bomb";
+   bind_map[93].nCode[0] = _BIND(A);
+   bind_map[93].nCode[1] = 1;
+
+   bind_map[94].bii_name = "P2 Special";
+   bind_map[94].nCode[0] = _BIND(A);
+   bind_map[94].nCode[1] = 1;
+
+   /* Ghouls 'n Ghosts */
+   bind_map[95].bii_name = "P2 Fire";
+   bind_map[95].nCode[0] = _BIND(Y);
+   bind_map[95].nCode[1] = 1;
+
+   /* TMNT */
+   bind_map[96].bii_name = "P2 Fire 1";
+   bind_map[96].nCode[0] = _BIND(Y);
+   bind_map[96].nCode[1] = 1;
+
+   bind_map[97].bii_name = "P2 Fire 2";
+   bind_map[97].nCode[0] = _BIND(B);
+   bind_map[97].nCode[1] = 1;
+
+   /* Strider */
+   bind_map[98].bii_name = "P2 Fire 3";
+   bind_map[98].nCode[0] = _BIND(A);
+   bind_map[98].nCode[1] = 1;
+
+   bind_map[99].bii_name = "Coin 2";
+   bind_map[99].nCode[0] = _BIND(SELECT);
+   bind_map[99].nCode[1] = 1;
+
+   /* Neo Geo */
+   bind_map[100].bii_name = "P2 Button A";
+   bind_map[100].nCode[0] = _BIND(B);
+   bind_map[100].nCode[1] = 1;
+
+   bind_map[101].bii_name = "P2 Button B";
+   bind_map[101].nCode[0] = _BIND(A);
+   bind_map[101].nCode[1] = 1;
+
+   bind_map[102].bii_name = "P2 Button C";
+   bind_map[102].nCode[0] = _BIND(Y);
+   bind_map[102].nCode[1] = 1;
+
+   bind_map[103].bii_name = "P2 Button D";
+   bind_map[103].nCode[0] = _BIND(X);
+   bind_map[103].nCode[1] = 1;
+
+   bind_map[104].bii_name = "P3 Coin";
+   bind_map[104].nCode[0] = _BIND(SELECT);
+   bind_map[104].nCode[1] = 2;
+
+   bind_map[105].bii_name = "P3 Start";
+   bind_map[105].nCode[0] = _BIND(START);
+   bind_map[105].nCode[1] = 2;
+
+   bind_map[106].bii_name = "P3 Up";
+   bind_map[106].nCode[0] = _BIND(UP);
+   bind_map[106].nCode[1] = 2;
+
+   bind_map[107].bii_name = "P3 Down";
+   bind_map[107].nCode[0] = _BIND(DOWN);
+   bind_map[107].nCode[1] = 2;
+
+   bind_map[108].bii_name = "P3 Left";
+   bind_map[108].nCode[0] = _BIND(LEFT);
+   bind_map[108].nCode[1] = 2;
+
+   bind_map[109].bii_name = "P3 Right";
+   bind_map[109].nCode[0] = _BIND(RIGHT);
+   bind_map[109].nCode[1] = 2;
+
+   bind_map[110].bii_name = "P3 Attack";
+   bind_map[110].nCode[0] = _BIND(Y);
+   bind_map[110].nCode[1] = 2;
+
+   bind_map[111].bii_name = "P3 Jump";
+   bind_map[111].nCode[0] = _BIND(B);
+   bind_map[111].nCode[1] = 2;
+
+   bind_map[112].bii_name = "P3 Pin";
+   bind_map[112].nCode[0] = _BIND(A);
+   bind_map[112].nCode[1] = 2;
+
+   bind_map[113].bii_name = "P3 Select";
+   bind_map[113].nCode[0] = _BIND(A);
+   bind_map[113].nCode[1] = 2;
+
+   bind_map[114].bii_name = "P3 Use";
+   bind_map[114].nCode[0] = _BIND(X);
+   bind_map[114].nCode[1] = 2;
+
+   /* Simpsons - Konami */
+   bind_map[115].bii_name = "P3 Button 1";
+   bind_map[115].nCode[0] = _BIND(Y);
+   bind_map[115].nCode[1] = 2;
+
+   bind_map[116].bii_name = "P3 Button 2";
+   bind_map[116].nCode[0] = _BIND(B);
+   bind_map[116].nCode[1] = 2;
+
+   bind_map[117].bii_name = "P3 Button 3";
+   bind_map[117].nCode[0] = _BIND(A);
+   bind_map[117].nCode[1] = 2;
+
+   bind_map[118].bii_name = "P3 Button 4";
+   bind_map[118].nCode[0] = _BIND(X);
+   bind_map[118].nCode[1] = 2;
+
+   /* TMNT */
+   bind_map[119].bii_name = "P3 Fire 1";
+   bind_map[119].nCode[0] = _BIND(Y);
+   bind_map[119].nCode[1] = 2;
+
+   bind_map[120].bii_name = "P3 Fire 2";
+   bind_map[120].nCode[0] = _BIND(B);
+   bind_map[120].nCode[1] = 2;
+
+   /* Strider */
+   bind_map[121].bii_name = "P3 Fire 3";
+   bind_map[121].nCode[0] = _BIND(A);
+   bind_map[121].nCode[1] = 2;
+
+   bind_map[122].bii_name = "Coin 3";
+   bind_map[122].nCode[0] = _BIND(SELECT);
+   bind_map[122].nCode[1] = 2;
+
+   bind_map[123].bii_name = "P4 Coin";
+   bind_map[123].nCode[0] = _BIND(SELECT);
+   bind_map[123].nCode[1] = 3;
+
+   bind_map[124].bii_name = "P4 Start";
+   bind_map[124].nCode[0] = _BIND(START);
+   bind_map[124].nCode[1] = 3;
+
+   bind_map[125].bii_name = "P4 Up";
+   bind_map[125].nCode[0] = _BIND(UP);
+   bind_map[125].nCode[1] = 3;
+
+   bind_map[126].bii_name = "P4 Down";
+   bind_map[126].nCode[0] = _BIND(DOWN);
+   bind_map[126].nCode[1] = 3;
+
+   bind_map[127].bii_name = "P4 Left";
+   bind_map[127].nCode[0] = _BIND(LEFT);
+   bind_map[127].nCode[1] = 3;
+
+   bind_map[128].bii_name = "P4 Right";
+   bind_map[128].nCode[0] = _BIND(RIGHT);
+   bind_map[128].nCode[1] = 3;
+
+   bind_map[129].bii_name = "P4 Attack";
+   bind_map[129].nCode[0] = _BIND(Y);
+   bind_map[129].nCode[1] = 3;
+
+   bind_map[130].bii_name = "P4 Jump";
+   bind_map[130].nCode[0] = _BIND(B);
+   bind_map[130].nCode[1] = 3;
+   
+   bind_map[131].bii_name = "P4 Pin";
+   bind_map[131].nCode[0] = _BIND(A);
+   bind_map[131].nCode[1] = 3;
+
+   bind_map[132].bii_name = "P4 Select";
+   bind_map[132].nCode[0] = _BIND(A);
+   bind_map[132].nCode[1] = 3;
+
+   bind_map[133].bii_name = "P4 Use";
+   bind_map[133].nCode[0] = _BIND(X);
+   bind_map[133].nCode[1] = 3;
+
+   /* Simpsons */
+   bind_map[134].bii_name = "P4 Button 1";
+   bind_map[134].nCode[0] = _BIND(Y);
+   bind_map[134].nCode[1] = 3;
+
+   bind_map[135].bii_name = "P4 Button 2";
+   bind_map[135].nCode[0] = _BIND(B);
+   bind_map[135].nCode[1] = 3;
+
+   bind_map[136].bii_name = "P4 Button 3";
+   bind_map[136].nCode[0] = _BIND(A);
+   bind_map[136].nCode[1] = 3;
+
+   bind_map[137].bii_name = "P4 Button 4";
+   bind_map[137].nCode[0] = _BIND(X);
+   bind_map[137].nCode[1] = 3;
+
+   /* TMNT */
+   bind_map[138].bii_name = "P4 Fire 1";
+   bind_map[138].nCode[0] = _BIND(Y);
+   bind_map[138].nCode[1] = 3;
+
+   bind_map[139].bii_name = "P4 Fire 2";
+   bind_map[139].nCode[0] = _BIND(B);
+   bind_map[139].nCode[1] = 3;
+
+   bind_map[140].bii_name = "P4 Fire 3";
+   bind_map[140].nCode[0] = _BIND(A);
+   bind_map[140].nCode[1] = 3;
+
+   bind_map[141].bii_name = "Coin 4";
+   bind_map[141].nCode[0] = _BIND(SELECT);
+   bind_map[141].nCode[1] = 3;
+
+   bind_map[142].bii_name = "Missile";
+   bind_map[142].nCode[0] = _BIND(A);
+   bind_map[142].nCode[1] = 3;
+
+   /* Afterburner */
+   bind_map[143].bii_name = "Vulcan";
+   bind_map[143].nCode[0] = _BIND(B);
+   bind_map[143].nCode[1] = 3;
+
+   bind_map[144].bii_name = "Throttle";
+   bind_map[144].nCode[0] = _BIND(Y);
+   bind_map[144].nCode[1] = 3;
+
+   for(unsigned int i = 0; i < nGameInpCount; i++, pgi++)
+   {
+      /* TODO: Cyberbots: Full Metal Madness */
+      /* TODO: Armored Warriors */
+      BurnDrvGetInputInfo(&bii, i);
+
+      bool value_found = false;
+      for(int j = 0; j < BIND_MAP_COUNT; j++)
+      {
+         if((strcmp(bii.szName,"P1 Select") ==0) && (boardrom && (strcmp(boardrom,"neogeo") == 0)))
+         {
+            keybinds[pgi->Input.Switch.nCode][0] = _BIND(SELECT);
+            keybinds[pgi->Input.Switch.nCode][1] = 0;
+            value_found = true;
+         }
+         else if((strcmp(bii.szName,"P1 Shot") ==0) && (parentrom && strcmp(parentrom,"avsp") == 0 || strcmp(drvname,"avsp") == 0))
+         {
+            keybinds[pgi->Input.Switch.nCode][0] = _BIND(A);
+            keybinds[pgi->Input.Switch.nCode][1] = 0;
+            value_found = true;
+         }
+         else if((strcmp(bii.szName,"P2 Select") ==0) && (boardrom && (strcmp(boardrom,"neogeo") == 0)))
+         {
+            keybinds[pgi->Input.Switch.nCode][0] = _BIND(SELECT);
+            keybinds[pgi->Input.Switch.nCode][1] = 1;
+            value_found = true;
+         }
+         else if((parentrom && strcmp(parentrom,"avsp") == 0 || strcmp(drvname,"avsp") == 0) && (strcmp(bii.szName,"P2 Shot") ==0))
+         {
+            keybinds[pgi->Input.Switch.nCode][0] = _BIND(A);
+            keybinds[pgi->Input.Switch.nCode][1] = 1;
+            value_found = true;
+         }
+         else if(strcmp(bii.szName, bind_map[j].bii_name) == 0)
+         {
+            keybinds[pgi->Input.Switch.nCode][0] = bind_map[j].nCode[0];
+            keybinds[pgi->Input.Switch.nCode][1] = bind_map[j].nCode[1];
+            value_found = true;
+         }
+         else
+            value_found = false;
+
+         if(value_found)
+         {
+            fprintf(stderr, "%s: %d.\n", bii.szName, pgi->Input.Switch.nCode );
+            break;
+         }
+      }
+
+      if(!value_found)
+         fprintf(stderr, "WARNING! Button accounted for: [%s].\n", bii.szName);
+   }
+
    // Reset
    keybinds[FBK_F3		][0] = RESET_BIND;
    keybinds[FBK_F3		][1] = 0;
-   keybinds[P1_SERVICE	][0] = SERVICE_BIND;
-   keybinds[P1_SERVICE	][1] = 0;
 
-   keybinds[P1_COIN	][0] = _BIND(SELECT);
-   keybinds[P1_COIN	][1] = 0;
-   keybinds[P1_START	][0] = _BIND(START);
-   keybinds[P1_START	][1] = 0;
-   keybinds[P1_UP	][0] = _BIND(UP);
-   keybinds[P1_UP	][1] = 0;
-   keybinds[P1_DOWN	][0] = _BIND(DOWN);
-   keybinds[P1_DOWN	][1] = 0;
-   keybinds[P1_LEFT	][0] = _BIND(LEFT);
-   keybinds[P1_LEFT	][1] = 0;
-   keybinds[P1_RIGHT	][0] = _BIND(RIGHT);
-   keybinds[P1_RIGHT	][1] = 0;
-   keybinds[P1_FIRE1	][0] = _BIND(Y);
-   keybinds[P1_FIRE1	][1] = 0;
-   keybinds[P1_FIRE2	][0] = _BIND(X);
-   keybinds[P1_FIRE2	][1] = 0;
-   keybinds[P1_FIRE3	][0] = _BIND(L);
-   keybinds[P1_FIRE3	][1] = 0;
-   keybinds[P1_FIRE4	][0] = _BIND(B);
-   keybinds[P1_FIRE4	][1] = 0;
-   keybinds[P1_FIRE5	][0] = _BIND(A);
-   keybinds[P1_FIRE5	][1] = 0;
+   // Service
+   keybinds[FBK_F2	][0] = SERVICE_BIND;
+   keybinds[FBK_F2   ][1] = 0;
 
-   if(boardrom && (strcmp(boardrom,"neogeo") == 0))
-   {
-      keybinds[P1_FIRE6][0] = _BIND(Y);
-      keybinds[P1_FIRE6][1] = 0;
-      keybinds[P1_FIRED][0] = _BIND(X);
-      keybinds[P1_FIRED][1] = 0;
-   }
-   else
-   {
-      keybinds[P1_FIRE6	][0] = _BIND(R);
-      keybinds[P1_FIRE6	][1] = 0;
-   }
+   return has_analog;
+}
 
-   keybinds[P2_COIN	][0] = _BIND(SELECT);
-   keybinds[P2_COIN	][1] = 1;
-   keybinds[P2_START	][0] = _BIND(START);
-   keybinds[P2_START	][1] = 1;
-   keybinds[P2_UP	][0] = _BIND(UP);
-   keybinds[P2_UP	][1] = 1;
-   keybinds[P2_DOWN	][0] = _BIND(DOWN);
-   keybinds[P2_DOWN	][1] = 1;
-   keybinds[P2_LEFT	][0] = _BIND(LEFT);
-   keybinds[P2_LEFT	][1] = 1;
-   keybinds[P2_RIGHT	][0] = _BIND(RIGHT);
-   keybinds[P2_RIGHT	][1] = 1;
-   keybinds[P2_FIRE1	][0] = _BIND(Y);
+//#define DEBUG_INPUT
+//
 
-   if (boardrom && (strcmp(boardrom, "neogeo") == 0))
+static inline int CinpJoyAxis(int i, int axis)
+{
+   switch(axis)
    {
-      keybinds[P2_FIRE3][0] = _BIND(Y);
-      keybinds[P2_FIRE3][1] = 1;
-      keybinds[P2_FIRE4][0] = _BIND(X);
-      keybinds[P2_FIRE4][1] = 1;
-      keybinds[P2_FIRE1][0] = _BIND(B);
-      keybinds[P2_FIRE1][1] = 1;
-      keybinds[P2_FIRE2][0] = _BIND(A);
-      keybinds[P2_FIRE2][1] = 1;
+      case 0:
+         return input_cb(i, RETRO_DEVICE_ANALOG, RETRO_DEVICE_INDEX_ANALOG_LEFT,
+               RETRO_DEVICE_ID_ANALOG_X);
+      case 1:
+         return input_cb(i, RETRO_DEVICE_ANALOG, RETRO_DEVICE_INDEX_ANALOG_LEFT,
+               RETRO_DEVICE_ID_ANALOG_Y);
+      case 2:
+         return 0;
+      case 3:
+         return input_cb(i, RETRO_DEVICE_ANALOG, RETRO_DEVICE_INDEX_ANALOG_RIGHT,
+               RETRO_DEVICE_ID_ANALOG_X);
+      case 4:
+         return input_cb(i, RETRO_DEVICE_ANALOG, RETRO_DEVICE_INDEX_ANALOG_RIGHT,
+               RETRO_DEVICE_ID_ANALOG_Y);
+      case 5:
+         return 0;
+      case 6:
+         return 0;
+      case 7:
+         return 0;
    }
-   else
-   {
-      keybinds[P2_FIRE1	][1] = 1;
-      keybinds[P2_FIRE2	][0] = _BIND(X);
-      keybinds[P2_FIRE2	][1] = 1;
-      keybinds[P2_FIRE3	][0] = _BIND(L);
-      keybinds[P2_FIRE3	][1] = 1;
-      keybinds[P2_FIRE4	][0] = _BIND(B);
-      keybinds[P2_FIRE4	][1] = 1;
-      keybinds[P2_FIRE5	][0] = _BIND(A);
-      keybinds[P2_FIRE5	][1] = 1;
-      keybinds[P2_FIRE6	][0] = _BIND(R);
-      keybinds[P2_FIRE6	][1] = 1;
-   }
+}
 
-#if 0
-   keybinds[0x4088		][0] = L2;
-   keybinds[0x4088		][1] = 1;
-   keybinds[0x408A		][0] = R2;
-   keybinds[0x408A		][1] = 1;
-   keybinds[0x408b		][0] = L3;
-   keybinds[0x408b		][1] = 1;
-   keybinds[0x408c		][0] = R3;
-   keybinds[0x408c		][1] = 1;
-#endif
+static inline int CinpMouseAxis(int i, int axis)
+{
+}
 
-   keybinds[P3_COIN	][0] = _BIND(SELECT);
-   keybinds[P3_COIN	][1] = 2;
-   keybinds[P3_START	][0] = _BIND(START);
-   keybinds[P3_START	][1] = 2;
-   keybinds[P3_UP	][0] = _BIND(UP);
-   keybinds[P3_UP	][1] = 2;
-   keybinds[P3_DOWN	][0] = _BIND(DOWN);
-   keybinds[P3_DOWN	][1] = 2;
-   keybinds[P3_LEFT	][0] = _BIND(LEFT);
-   keybinds[P3_LEFT	][1] = 2;
-   keybinds[P3_RIGHT	][0] = _BIND(RIGHT);
-   keybinds[P3_RIGHT	][1] = 2;
-   keybinds[P3_FIRE1	][0] = _BIND(Y);
-   keybinds[P3_FIRE1	][1] = 2;
-   keybinds[P3_FIRE2	][0] = _BIND(X);
-   keybinds[P3_FIRE2	][1] = 2;
-   keybinds[P3_FIRE3	][0] = _BIND(L);
-   keybinds[P3_FIRE3	][1] = 2;
-   keybinds[P3_FIRE4	][0] = _BIND(B);
-   keybinds[P3_FIRE4	][1] = 2;
-   keybinds[P3_FIRE5	][0] = _BIND(A);
-   keybinds[P3_FIRE5	][1] = 2;
-   keybinds[P3_FIRE6	][0] = _BIND(R);
-   keybinds[P3_FIRE6	][1] = 2;
-#if 0
-   keybinds[0x4188		][0] = L2;
-   keybinds[0x4188		][1] = 2;
-   keybinds[0x418A		][0] = R2;
-   keybinds[0x418A		][1] = 2;
-   keybinds[0x418b		][0] = L3;
-   keybinds[0x418b		][1] = 2;
-   keybinds[0x418c		][0] = R3;
-   keybinds[0x418c		][1] = 2;
-#endif
-
-   keybinds[P4_COIN	][0] = _BIND(SELECT);
-   keybinds[P4_COIN	][1] = 3;
-   keybinds[P4_START	][0] = _BIND(START);
-   keybinds[P4_START	][1] = 3;
-   keybinds[P4_UP	][0] = _BIND(UP);
-   keybinds[P4_UP	][1] = 3;
-   keybinds[P4_DOWN	][0] = _BIND(DOWN);
-   keybinds[P4_DOWN	][1] = 3;
-   keybinds[P4_LEFT	][0] = _BIND(LEFT);
-   keybinds[P4_LEFT	][1] = 3;
-   keybinds[P4_RIGHT	][0] = _BIND(RIGHT);
-   keybinds[P4_RIGHT	][1] = 3;
-   keybinds[P4_FIRE1	][0] = _BIND(Y);
-   keybinds[P4_FIRE1	][1] = 3;
-   keybinds[P4_FIRE2	][0] = _BIND(X);
-   keybinds[P4_FIRE2	][1] = 3;
-   keybinds[P4_FIRE3	][0] = _BIND(L);
-   keybinds[P4_FIRE3	][1] = 3;
-   keybinds[P4_FIRE4	][0] = _BIND(B);
-   keybinds[P4_FIRE4	][1] = 3;
-   keybinds[P4_FIRE5	][0] = _BIND(A);
-   keybinds[P4_FIRE5	][1] = 3;
-   keybinds[P4_FIRE6	][0] = _BIND(R);
-   keybinds[P4_FIRE6	][1] = 3;
-#if 0
-   keybinds[0x4288		][0] = L2;
-   keybinds[0x4288		][1] = 3;
-   keybinds[0x428A		][0] = R2;
-   keybinds[0x428A		][1] = 3;
-   keybinds[0x428b		][0] = L3;
-   keybinds[0x428b		][1] = 3;
-   keybinds[0x428c		][0] = R3;
-   keybinds[0x428c		][1] = 3;
-#endif
-
-   return has_analog;
+static inline int CinpState(int i)
+{
+   return keybinds[i][0];
 }
 
-static void poll_input()
+static void poll_input(void)
 {
    poll_cb();
 
@@ -815,19 +1382,17 @@
    for (int i = 0; i < controller_binds_count; i++, pgi++)
    {
       int nAdd = 0;
+
       if ((pgi->nInput & GIT_GROUP_SLIDER) == 0)                           // not a slider
          continue;
 
       if (pgi->nInput == GIT_KEYSLIDER)
       {
          // Get states of the two keys
-         if (input_cb(0, RETRO_DEVICE_JOYPAD, 0,
-                  keybinds[pgi->Input.Slider.SliderAxis.nSlider[0]][0]))
-            nAdd -= 0x100;
-
-         if (input_cb(0, RETRO_DEVICE_JOYPAD, 0,
-                  keybinds[pgi->Input.Slider.SliderAxis.nSlider[1]][0]))
-            nAdd += 0x100;
+			if (input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(LEFT)))
+				nAdd -= 0x100;
+			if (input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(RIGHT)))
+				nAdd += 0x100;
       }
 
       // nAdd is now -0x100 to +0x100
@@ -857,77 +1422,182 @@
 
    for (unsigned i = 0; i < controller_binds_count; i++, pgi++)
    {
+      if (pgi->Input.pVal == NULL)
+         continue;
+
       switch (pgi->nInput)
       {
+         case 0:									// Undefined
+            pgi->Input.nVal = 0;
+            break;
          case GIT_CONSTANT: // Constant value
             pgi->Input.nVal = pgi->Input.Constant.nConst;
-            *(pgi->Input.pVal) = pgi->Input.nVal;
+#ifdef LSB_FIRST
+            *(pgi->Input.pShortVal) = pgi->Input.nVal;
+#else
+            *((int *)pgi->Input.pShortVal) = pgi->Input.nVal;
+#endif
             break;
          case GIT_SWITCH:
-         {
-            // Digital input
-            unsigned id = keybinds[pgi->Input.Switch.nCode][0];
-            unsigned port = keybinds[pgi->Input.Switch.nCode][1];
+            {
+               // Digital input
+               INT32 s = CinpState(pgi->Input.Switch.nCode);
+               unsigned port = keybinds[pgi->Input.Switch.nCode][1];
 
-            bool state;
-            if (id == RESET_BIND)
+               bool state;
+               if (s == RESET_BIND)
+               {
+                  state = g_reset;
+                  g_reset = false;
+                  Reinitialise();
+               }
+               else if (s == SERVICE_BIND)
+               {
+                  state =
+                     input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(START)) &&
+                     input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(SELECT)) &&
+                     input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(L)) &&
+                     input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(R)) &&
+                     input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(DOWN));
+                  Reinitialise();
+               }
+               else
+                  state = input_cb(port, RETRO_DEVICE_JOYPAD, 0, s);
+
+               if (pgi->nType & BIT_GROUP_ANALOG)
+               {
+                  // Set analog controls to full
+                  if (state)
+                     pgi->Input.nVal = 0xFFFF;
+                  else
+                     pgi->Input.nVal = 0x0001;
+#ifdef LSB_FIRST
+                  *(pgi->Input.pShortVal) = pgi->Input.nVal;
+#else
+                  *((int *)pgi->Input.pShortVal) = pgi->Input.nVal;
+#endif
+               }
+               else
+               {
+                  // Binary controls
+                  if (state)
+                     pgi->Input.nVal = 1;
+                  else
+                     pgi->Input.nVal = 0;
+                  *(pgi->Input.pVal) = pgi->Input.nVal;
+               }
+               break;
+            }
+         case GIT_KEYSLIDER:						// Keyboard slider
+         case GIT_JOYSLIDER:	 					// Joystick slider
             {
-               state = g_reset;
-               g_reset = false;
-	       Reinitialise();
+               int nSlider = pgi->Input.Slider.nSliderValue;
+               if (pgi->nType == BIT_ANALOG_REL) {
+                  nSlider -= 0x8000;
+                  nSlider >>= 4;
+               }
+
+               pgi->Input.nVal = (unsigned short)nSlider;
+#ifdef LSB_FIRST
+               *(pgi->Input.pShortVal) = pgi->Input.nVal;
+#else
+               *((int *)pgi->Input.pShortVal) = pgi->Input.nVal;
+#endif
+               break;
             }
-            else if (id == SERVICE_BIND)
+         case GIT_MOUSEAXIS:						// Mouse axis
             {
-               state =
-                  input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(START)) &&
-                  input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(SELECT)) &&
-                  input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(L)) &&
-                  input_cb(0, RETRO_DEVICE_JOYPAD, 0, _BIND(R));
-               Reinitialise();
+               pgi->Input.nVal = (UINT16)(CinpMouseAxis(pgi->Input.MouseAxis.nMouse, pgi->Input.MouseAxis.nAxis) * nAnalogSpeed);
+#ifdef LSB_FIRST
+               *(pgi->Input.pShortVal) = pgi->Input.nVal;
+#else
+               *((int *)pgi->Input.pShortVal) = pgi->Input.nVal;
+#endif
             }
-            else
-               state = input_cb(port, RETRO_DEVICE_JOYPAD, 0, id);
+            break;
+         case GIT_JOYAXIS_FULL:
+            {				// Joystick axis
+               INT32 nJoy = CinpJoyAxis(pgi->Input.JoyAxis.nJoy, pgi->Input.JoyAxis.nAxis);
 
-            if (pgi->nType & BIT_GROUP_ANALOG)
-            {
-               // Set analog controls to full
-               if (state)
-                  pgi->Input.nVal = 0xFFFF;
-               else
-                  pgi->Input.nVal = 0x0001;
+               if (pgi->nType == BIT_ANALOG_REL) {
+                  nJoy *= nAnalogSpeed;
+                  nJoy >>= 13;
+
+                  // Clip axis to 8 bits
+                  if (nJoy < -32768) {
+                     nJoy = -32768;
+                  }
+                  if (nJoy >  32767) {
+                     nJoy =  32767;
+                  }
+               } else {
+                  nJoy >>= 1;
+                  nJoy += 0x8000;
+
+                  // Clip axis to 16 bits
+                  if (nJoy < 0x0001) {
+                     nJoy = 0x0001;
+                  }
+                  if (nJoy > 0xFFFF) {
+                     nJoy = 0xFFFF;
+                  }
+               }
+
+               pgi->Input.nVal = (UINT16)nJoy;
 #ifdef LSB_FIRST
                *(pgi->Input.pShortVal) = pgi->Input.nVal;
 #else
                *((int *)pgi->Input.pShortVal) = pgi->Input.nVal;
 #endif
+               break;
             }
-            else
-            {
-               // Binary controls
-               if (state)
-                  pgi->Input.nVal = 1;
+         case GIT_JOYAXIS_NEG:
+            {				// Joystick axis Lo
+               INT32 nJoy = CinpJoyAxis(pgi->Input.JoyAxis.nJoy, pgi->Input.JoyAxis.nAxis);
+               if (nJoy < 32767)
+               {
+                  nJoy = -nJoy;
+
+                  if (nJoy < 0x0000)
+                     nJoy = 0x0000;
+                  if (nJoy > 0xFFFF)
+                     nJoy = 0xFFFF;
+
+                  pgi->Input.nVal = (UINT16)nJoy;
+               }
                else
                   pgi->Input.nVal = 0;
-               *(pgi->Input.pVal) = pgi->Input.nVal;
+
+#ifdef LSB_FIRST
+               *(pgi->Input.pShortVal) = pgi->Input.nVal;
+#else
+               *((int *)pgi->Input.pShortVal) = pgi->Input.nVal;
+#endif
+               break;
             }
-            break;
-         }
-         case GIT_KEYSLIDER:						// Keyboard slider
-         {
-            int nSlider = pgi->Input.Slider.nSliderValue;
-            if (pgi->nType == BIT_ANALOG_REL) {
-               nSlider -= 0x8000;
-               nSlider >>= 4;
-            }
+         case GIT_JOYAXIS_POS:
+            {				// Joystick axis Hi
+               INT32 nJoy = CinpJoyAxis(pgi->Input.JoyAxis.nJoy, pgi->Input.JoyAxis.nAxis);
+               if (nJoy > 32767)
+               {
 
-            pgi->Input.nVal = (unsigned short)nSlider;
+                  if (nJoy < 0x0000)
+                     nJoy = 0x0000;
+                  if (nJoy > 0xFFFF)
+                     nJoy = 0xFFFF;
+
+                  pgi->Input.nVal = (UINT16)nJoy;
+               }
+               else
+                  pgi->Input.nVal = 0;
+
 #ifdef LSB_FIRST
-            *(pgi->Input.pShortVal) = pgi->Input.nVal;
+               *(pgi->Input.pShortVal) = pgi->Input.nVal;
 #else
-            *((int *)pgi->Input.pShortVal) = pgi->Input.nVal;
+               *((int *)pgi->Input.pShortVal) = pgi->Input.nVal;
 #endif
-            break;
-         }
+               break;
+            }
       }
    }
 }
@@ -945,3 +1615,19 @@
    return ret;
 }
 
+#ifdef ANDROID
+#include <wchar.h>
+
+size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n)
+{
+   if (pwcs == NULL)
+      return strlen(s);
+   return mbsrtowcs(pwcs, &s, n, NULL);
+}
+
+size_t wcstombs(char *s, const wchar_t *pwcs, size_t n)
+{
+   return wcsrtombs(s, &pwcs, n, NULL);
+}
+
+#endif
Index: src/burner/libretro/libretro.h
===================================================================
--- src/burner/libretro/libretro.h	(revision 847)
+++ src/burner/libretro/libretro.h	(working copy)
@@ -3,27 +3,66 @@
 
 #include <stdint.h>
 #include <stddef.h>
+#include <limits.h>
 
+// Hack applied for MSVC when compiling in C89 mode as it isn't C99 compliant.
 #ifdef __cplusplus
 extern "C" {
 #else
+#if defined(_MSC_VER) && !defined(SN_TARGET_PS3) && !defined(__cplusplus)
+#define bool unsigned char
+#define true 1
+#define false 0
+#else
 #include <stdbool.h>
 #endif
+#endif
 
+// Used for checking API/ABI mismatches that can break libretro implementations.
+// It is not incremented for compatible changes.
 #define RETRO_API_VERSION         1
 
+// Libretro's fundamental device abstractions.
 #define RETRO_DEVICE_MASK         0xff
 #define RETRO_DEVICE_NONE         0
+
+// The JOYPAD is called RetroPad. It is essentially a Super Nintendo controller,
+// but with additional L2/R2/L3/R3 buttons, similar to a PS1 DualShock.
 #define RETRO_DEVICE_JOYPAD       1
+
+// The mouse is a simple mouse, similar to Super Nintendo's mouse.
+// X and Y coordinates are reported relatively to last poll (poll callback).
+// It is up to the libretro implementation to keep track of where the mouse pointer is supposed to be on the screen.
+// The frontend must make sure not to interfere with its own hardware mouse pointer.
 #define RETRO_DEVICE_MOUSE        2
+
+// KEYBOARD device lets one poll for raw key pressed.
+// It is poll based, so input callback will return with the current pressed state.
 #define RETRO_DEVICE_KEYBOARD     3
+
+// Lightgun X/Y coordinates are reported relatively to last poll, similar to mouse.
 #define RETRO_DEVICE_LIGHTGUN     4
 
+// The ANALOG device is an extension to JOYPAD (RetroPad).
+// Similar to DualShock it adds two analog sticks.
+// This is treated as a separate device type as it returns values in the full analog range
+// of [-0x8000, 0x7fff]. Positive X axis is right. Positive Y axis is down.
+// Only use ANALOG type when polling for analog values of the axes.
+#define RETRO_DEVICE_ANALOG       5
+
+// These device types are specializations of the base types above.
+// They should only be used in retro_set_controller_type() to inform libretro implementations
+// about use of a very specific device type.
+//
+// In input state callback, however, only the base type should be used in the 'device' field.
 #define RETRO_DEVICE_JOYPAD_MULTITAP        ((1 << 8) | RETRO_DEVICE_JOYPAD)
 #define RETRO_DEVICE_LIGHTGUN_SUPER_SCOPE   ((1 << 8) | RETRO_DEVICE_LIGHTGUN)
 #define RETRO_DEVICE_LIGHTGUN_JUSTIFIER     ((2 << 8) | RETRO_DEVICE_LIGHTGUN)
 #define RETRO_DEVICE_LIGHTGUN_JUSTIFIERS    ((3 << 8) | RETRO_DEVICE_LIGHTGUN)
 
+// Buttons for the RetroPad (JOYPAD).
+// The placement of these is equivalent to placements on the Super Nintendo controller.
+// L2/R2/L3/R3 buttons correspond to the PS1 DualShock.
 #define RETRO_DEVICE_ID_JOYPAD_B        0
 #define RETRO_DEVICE_ID_JOYPAD_Y        1
 #define RETRO_DEVICE_ID_JOYPAD_SELECT   2
@@ -36,27 +75,56 @@
 #define RETRO_DEVICE_ID_JOYPAD_X        9
 #define RETRO_DEVICE_ID_JOYPAD_L       10
 #define RETRO_DEVICE_ID_JOYPAD_R       11
+#define RETRO_DEVICE_ID_JOYPAD_L2      12
+#define RETRO_DEVICE_ID_JOYPAD_R2      13
+#define RETRO_DEVICE_ID_JOYPAD_L3      14
+#define RETRO_DEVICE_ID_JOYPAD_R3      15
 
+// Index / Id values for ANALOG device.
+#define RETRO_DEVICE_INDEX_ANALOG_LEFT   0
+#define RETRO_DEVICE_INDEX_ANALOG_RIGHT  1
+#define RETRO_DEVICE_ID_ANALOG_X         0
+#define RETRO_DEVICE_ID_ANALOG_Y         1
+
+// Id values for MOUSE.
 #define RETRO_DEVICE_ID_MOUSE_X      0
 #define RETRO_DEVICE_ID_MOUSE_Y      1
 #define RETRO_DEVICE_ID_MOUSE_LEFT   2
 #define RETRO_DEVICE_ID_MOUSE_RIGHT  3
 
+// Id values for LIGHTGUN types.
 #define RETRO_DEVICE_ID_LIGHTGUN_X        0
 #define RETRO_DEVICE_ID_LIGHTGUN_Y        1
 #define RETRO_DEVICE_ID_LIGHTGUN_TRIGGER  2
 #define RETRO_DEVICE_ID_LIGHTGUN_CURSOR   3
 #define RETRO_DEVICE_ID_LIGHTGUN_TURBO    4
 #define RETRO_DEVICE_ID_LIGHTGUN_PAUSE    5
+#define RETRO_DEVICE_ID_LIGHTGUN_START    6
 
+// Returned from retro_get_region().
 #define RETRO_REGION_NTSC  0
 #define RETRO_REGION_PAL   1
 
+// Passed to retro_get_memory_data/size().
+// If the memory type doesn't apply to the implementation NULL/0 can be returned.
 #define RETRO_MEMORY_MASK        0xff
+
+// Regular save ram. This ram is usually found on a game cartridge, backed up by a battery.
+// If save game data is too complex for a single memory buffer,
+// the SYSTEM_DIRECTORY environment callback can be used.
 #define RETRO_MEMORY_SAVE_RAM    0
+
+// Some games have a built-in clock to keep track of time.
+// This memory is usually just a couple of bytes to keep track of time.
 #define RETRO_MEMORY_RTC         1
+
+// System ram lets a frontend peek into a game systems main RAM.
 #define RETRO_MEMORY_SYSTEM_RAM  2
 
+// Video ram lets a frontend peek into a game systems video RAM (VRAM).
+#define RETRO_MEMORY_VIDEO_RAM   3
+
+// Special memory types.
 #define RETRO_MEMORY_SNES_BSX_RAM             ((1 << 8) | RETRO_MEMORY_SAVE_RAM)
 #define RETRO_MEMORY_SNES_BSX_PRAM            ((2 << 8) | RETRO_MEMORY_SAVE_RAM)
 #define RETRO_MEMORY_SNES_SUFAMI_TURBO_A_RAM  ((3 << 8) | RETRO_MEMORY_SAVE_RAM)
@@ -64,12 +132,162 @@
 #define RETRO_MEMORY_SNES_GAME_BOY_RAM        ((5 << 8) | RETRO_MEMORY_SAVE_RAM)
 #define RETRO_MEMORY_SNES_GAME_BOY_RTC        ((6 << 8) | RETRO_MEMORY_RTC)
 
+// Special game types passed into retro_load_game_special().
+// Only used when multiple ROMs are required.
 #define RETRO_GAME_TYPE_BSX             0x101
 #define RETRO_GAME_TYPE_BSX_SLOTTED     0x102
 #define RETRO_GAME_TYPE_SUFAMI_TURBO    0x103
 #define RETRO_GAME_TYPE_SUPER_GAME_BOY  0x104
 
+// Keysyms used for ID in input state callback when polling RETRO_KEYBOARD.
+enum retro_key
+{
+   RETROK_UNKNOWN        = 0,
+   RETROK_FIRST          = 0,
+   RETROK_BACKSPACE      = 8,
+   RETROK_TAB            = 9,
+   RETROK_CLEAR          = 12,
+   RETROK_RETURN         = 13,
+   RETROK_PAUSE          = 19,
+   RETROK_ESCAPE         = 27,
+   RETROK_SPACE          = 32,
+   RETROK_EXCLAIM        = 33,
+   RETROK_QUOTEDBL       = 34,
+   RETROK_HASH           = 35,
+   RETROK_DOLLAR         = 36,
+   RETROK_AMPERSAND      = 38,
+   RETROK_QUOTE          = 39,
+   RETROK_LEFTPAREN      = 40,
+   RETROK_RIGHTPAREN     = 41,
+   RETROK_ASTERISK       = 42,
+   RETROK_PLUS           = 43,
+   RETROK_COMMA          = 44,
+   RETROK_MINUS          = 45,
+   RETROK_PERIOD         = 46,
+   RETROK_SLASH          = 47,
+   RETROK_0              = 48,
+   RETROK_1              = 49,
+   RETROK_2              = 50,
+   RETROK_3              = 51,
+   RETROK_4              = 52,
+   RETROK_5              = 53,
+   RETROK_6              = 54,
+   RETROK_7              = 55,
+   RETROK_8              = 56,
+   RETROK_9              = 57,
+   RETROK_COLON          = 58,
+   RETROK_SEMICOLON      = 59,
+   RETROK_LESS           = 60,
+   RETROK_EQUALS         = 61,
+   RETROK_GREATER        = 62,
+   RETROK_QUESTION       = 63,
+   RETROK_AT             = 64,
+   RETROK_LEFTBRACKET    = 91,
+   RETROK_BACKSLASH      = 92,
+   RETROK_RIGHTBRACKET   = 93,
+   RETROK_CARET          = 94,
+   RETROK_UNDERSCORE     = 95,
+   RETROK_BACKQUOTE      = 96,
+   RETROK_a              = 97,
+   RETROK_b              = 98,
+   RETROK_c              = 99,
+   RETROK_d              = 100,
+   RETROK_e              = 101,
+   RETROK_f              = 102,
+   RETROK_g              = 103,
+   RETROK_h              = 104,
+   RETROK_i              = 105,
+   RETROK_j              = 106,
+   RETROK_k              = 107,
+   RETROK_l              = 108,
+   RETROK_m              = 109,
+   RETROK_n              = 110,
+   RETROK_o              = 111,
+   RETROK_p              = 112,
+   RETROK_q              = 113,
+   RETROK_r              = 114,
+   RETROK_s              = 115,
+   RETROK_t              = 116,
+   RETROK_u              = 117,
+   RETROK_v              = 118,
+   RETROK_w              = 119,
+   RETROK_x              = 120,
+   RETROK_y              = 121,
+   RETROK_z              = 122,
+   RETROK_DELETE         = 127,
 
+   RETROK_KP0            = 256,
+   RETROK_KP1            = 257,
+   RETROK_KP2            = 258,
+   RETROK_KP3            = 259,
+   RETROK_KP4            = 260,
+   RETROK_KP5            = 261,
+   RETROK_KP6            = 262,
+   RETROK_KP7            = 263,
+   RETROK_KP8            = 264,
+   RETROK_KP9            = 265,
+   RETROK_KP_PERIOD      = 266,
+   RETROK_KP_DIVIDE      = 267,
+   RETROK_KP_MULTIPLY    = 268,
+   RETROK_KP_MINUS       = 269,
+   RETROK_KP_PLUS        = 270,
+   RETROK_KP_ENTER       = 271,
+   RETROK_KP_EQUALS      = 272,
+
+   RETROK_UP             = 273,
+   RETROK_DOWN           = 274,
+   RETROK_RIGHT          = 275,
+   RETROK_LEFT           = 276,
+   RETROK_INSERT         = 277,
+   RETROK_HOME           = 278,
+   RETROK_END            = 279,
+   RETROK_PAGEUP         = 280,
+   RETROK_PAGEDOWN       = 281,
+
+   RETROK_F1             = 282,
+   RETROK_F2             = 283,
+   RETROK_F3             = 284,
+   RETROK_F4             = 285,
+   RETROK_F5             = 286,
+   RETROK_F6             = 287,
+   RETROK_F7             = 288,
+   RETROK_F8             = 289,
+   RETROK_F9             = 290,
+   RETROK_F10            = 291,
+   RETROK_F11            = 292,
+   RETROK_F12            = 293,
+   RETROK_F13            = 294,
+   RETROK_F14            = 295,
+   RETROK_F15            = 296,
+
+   RETROK_NUMLOCK        = 300,
+   RETROK_CAPSLOCK       = 301,
+   RETROK_SCROLLOCK      = 302,
+   RETROK_RSHIFT         = 303,
+   RETROK_LSHIFT         = 304,
+   RETROK_RCTRL          = 305,
+   RETROK_LCTRL          = 306,
+   RETROK_RALT           = 307,
+   RETROK_LALT           = 308,
+   RETROK_RMETA          = 309,
+   RETROK_LMETA          = 310,
+   RETROK_LSUPER         = 311,
+   RETROK_RSUPER         = 312,
+   RETROK_MODE           = 313,
+   RETROK_COMPOSE        = 314,
+
+   RETROK_HELP           = 315,
+   RETROK_PRINT          = 316,
+   RETROK_SYSREQ         = 317,
+   RETROK_BREAK          = 318,
+   RETROK_MENU           = 319,
+   RETROK_POWER          = 320,
+   RETROK_EURO           = 321,
+   RETROK_UNDO           = 322,
+
+   RETROK_LAST
+};
+
 // Environment commands.
 #define RETRO_ENVIRONMENT_SET_ROTATION  1  // const unsigned * --
                                            // Sets screen rotation of graphics.
@@ -81,7 +299,7 @@
                                            // Boolean value whether or not the implementation should use overscan, or crop away overscan.
                                            //
 #define RETRO_ENVIRONMENT_GET_CAN_DUPE  3  // bool * --
-                                           // Boolean value whether or not SSNES supports frame duping,
+                                           // Boolean value whether or not frontend supports frame duping,
                                            // passing NULL to video frame callback.
                                            //
 #define RETRO_ENVIRONMENT_GET_VARIABLE  4  // struct retro_variable * --
@@ -98,20 +316,117 @@
                                            //
 #define RETRO_ENVIRONMENT_SET_MESSAGE   6  // const struct retro_message * --
                                            // Sets a message to be displayed in implementation-specific manner for a certain amount of 'frames'.
+                                           // Should not be used for trivial messages, which should simply be logged to stderr.
+#define RETRO_ENVIRONMENT_SHUTDOWN      7  // N/A (NULL) --
+                                           // Requests the frontend to shutdown.
+                                           // Should only be used if game has a specific
+                                           // way to shutdown the game from a menu item or similar.
+                                           //
+#define RETRO_ENVIRONMENT_SET_PERFORMANCE_LEVEL 8
+                                           // const unsigned * --
+                                           // Gives a hint to the frontend how demanding this implementation
+                                           // is on a system. E.g. reporting a level of 2 means
+                                           // this implementation should run decently on all frontends
+                                           // of level 2 and up.
+                                           //
+                                           // It can be used by the frontend to potentially warn
+                                           // about too demanding implementations.
+                                           // 
+                                           // The levels are "floating", but roughly defined as:
+                                           // 0: Low-powered embedded devices such as Raspberry Pi
+                                           // 1: 6th generation consoles, such as Wii/Xbox 1, and phones, tablets, etc.
+                                           // 2: 7th generation consoles, such as PS3/360, with sub-par CPUs.
+                                           // 3: Modern desktop/laptops with reasonably powerful CPUs.
+                                           // 4: High-end desktops with very powerful CPUs.
+                                           //
+                                           // This function can be called on a per-game basis,
+                                           // as certain games an implementation can play might be
+                                           // particularily demanding.
+                                           // If called, it should be called in retro_load_game().
+                                           //
+#define RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY 9
+                                           // const char ** --
+                                           // Returns the "system" directory of the frontend.
+                                           // This directory can be used to store system specific ROMs such as BIOSes, configuration data, etc.
+                                           // The returned value can be NULL.
+                                           // If so, no such directory is defined,
+                                           // and it's up to the implementation to find a suitable directory.
+                                           //
+#define RETRO_ENVIRONMENT_SET_PIXEL_FORMAT 10
+                                           // const enum retro_pixel_format * --
+                                           // Sets the internal pixel format used by the implementation.
+                                           // The default pixel format is RETRO_PIXEL_FORMAT_0RGB1555.
+                                           // This pixel format however, is deprecated (see enum retro_pixel_format).
+                                           // If the call returns false, the frontend does not support this pixel format.
+                                           // This function should be called inside retro_load_game() or retro_get_system_av_info().
+                                           //
+#define RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS 11
+                                           // const struct retro_input_descriptor * --
+                                           // Sets an array of retro_input_descriptors.
+                                           // It is up to the frontend to present this in a usable way.
+                                           // The array is terminated by retro_input_descriptor::description being set to NULL.
+                                           // This function can be called at any time, but it is recommended to call it as early as possible.
 
+
+enum retro_pixel_format
+{
+   // 0RGB1555, native endian. 0 bit must be set to 0.
+   // This pixel format is default for compatibility concerns only.
+   // If a 15/16-bit pixel format is desired, consider using RGB565.
+   RETRO_PIXEL_FORMAT_0RGB1555 = 0,
+
+   // XRGB8888, native endian. X bits are ignored.
+   RETRO_PIXEL_FORMAT_XRGB8888 = 1,
+
+   // RGB565, native endian. This pixel format is the recommended format to use if a 15/16-bit format is desired
+   // as it is the pixel format that is typically available on a wide range of low-power devices.
+   // It is also natively supported in APIs like OpenGL ES.
+   RETRO_PIXEL_FORMAT_RGB565   = 2,
+
+   // Ensure sizeof() == sizeof(int).
+   RETRO_PIXEL_FORMAT_UNKNOWN  = INT_MAX
+};
+
 struct retro_message
 {
-   const char *msg;
-   unsigned    frames;
+   const char *msg;        // Message to be displayed.
+   unsigned    frames;     // Duration in frames of message.
 };
 
+// Describes how the libretro implementation maps a libretro input bind
+// to its internal input system through a human readable string.
+// This string can be used to better let a user configure input.
+struct retro_input_descriptor
+{
+   // Associates given parameters with a description.
+   unsigned port;
+   unsigned device;
+   unsigned index;
+   unsigned id;
+
+   const char *description; // Human readable description for parameters.
+                            // The pointer must remain valid until retro_unload_game() is called.
+};
+
 struct retro_system_info
 {
-   const char *library_name;
-   const char *library_version;
-   const char *valid_extensions;
-   bool        need_fullpath;
-   bool        block_extract;
+   // All pointers are owned by libretro implementation, and pointers must remain valid until retro_deinit() is called.
+
+   const char *library_name;      // Descriptive name of library. Should not contain any version numbers, etc.
+   const char *library_version;   // Descriptive version of core.
+
+   const char *valid_extensions;  // A string listing probably rom extensions the core will be able to load, separated with pipe.
+                                  // I.e. "bin|rom|iso".
+                                  // Typically used for a GUI to filter out extensions.
+
+   bool        need_fullpath;     // If true, retro_load_game() is guaranteed to provide a valid pathname in retro_game_info::path.
+                                  // ::data and ::size are both invalid.
+                                  // If false, ::data and ::size are guaranteed to be valid, but ::path might not be valid.
+                                  // This is typically set to true for libretro implementations that must load from file.
+                                  // Implementations should strive for setting this to false, as it allows the frontend to perform patching, etc.
+
+   bool        block_extract;     // If true, the frontend is not allowed to extract any archives before loading the real ROM.
+                                  // Necessary for certain libretro implementations that load games from zipped archives.
 };
 
 struct retro_game_geometry
@@ -151,62 +466,107 @@
 {
    const char *path;       // Path to game, UTF-8 encoded. Usually used as a reference.
                            // May be NULL if rom was loaded from stdin or similar.
-                           // SET_NEED_FULLPATH path guaranteed that this path is valid.
-   const void *data;       // Memory buffer of loaded game.
-                           // If the game is too big to load in one go.
-                           // SET_NEED_FULLPATH should be used.
-                           // In this case, data and size will be 0,
-                           // and game can be loaded from path.
+                           // retro_system_info::need_fullpath guaranteed that this path is valid.
+   const void *data;       // Memory buffer of loaded game. Will be NULL if need_fullpath was set.
    size_t      size;       // Size of memory buffer.
    const char *meta;       // String of implementation specific meta-data.
 };
 
+// Callbacks
+//
+// Environment callback. Gives implementations a way of performing uncommon tasks. Extensible.
 typedef bool (*retro_environment_t)(unsigned cmd, void *data);
+
+// Render a frame. Pixel format is 15-bit 0RGB1555 native endian unless changed (see RETRO_ENVIRONMENT_SET_PIXEL_FORMAT).
+// Width and height specify dimensions of buffer.
+// Pitch specifices length in bytes between two lines in buffer.
+// For performance reasons, it is highly recommended to have a frame that is packed in memory, i.e. pitch == width * byte_per_pixel.
+// Certain graphic APIs, such as OpenGL ES, do not like textures that are not packed in memory.
 typedef void (*retro_video_refresh_t)(const void *data, unsigned width, unsigned height, size_t pitch);
+
+// Renders a single audio frame. Should only be used if implementation generates a single sample at a time.
+// Format is signed 16-bit native endian.
 typedef void (*retro_audio_sample_t)(int16_t left, int16_t right);
+// Renders multiple audio frames in one go. One frame is defined as a sample of left and right channels, interleaved.
+// I.e. int16_t buf[4] = { l, r, l, r }; would be 2 frames.
+// Only one of the audio callbacks must ever be used.
 typedef size_t (*retro_audio_sample_batch_t)(const int16_t *data, size_t frames);
 
+// Polls input.
 typedef void (*retro_input_poll_t)(void);
+// Queries for input for player 'port'. device will be masked with RETRO_DEVICE_MASK.
+// Specialization of devices such as RETRO_DEVICE_JOYPAD_MULTITAP that have been set with retro_set_controller_port_device()
+// will still use the higher level RETRO_DEVICE_JOYPAD to request input.
 typedef int16_t (*retro_input_state_t)(unsigned port, unsigned device, unsigned index, unsigned id);
 
+// Sets callbacks. retro_set_environment() is guaranteed to be called before retro_init().
+// The rest of the set_* functions are guaranteed to have been called before the first call to retro_run() is made.
+void retro_set_environment(retro_environment_t);
+void retro_set_video_refresh(retro_video_refresh_t);
+void retro_set_audio_sample(retro_audio_sample_t);
+void retro_set_audio_sample_batch(retro_audio_sample_batch_t);
+void retro_set_input_poll(retro_input_poll_t);
+void retro_set_input_state(retro_input_state_t);
+
+// Library global initialization/deinitialization.
 void retro_init(void);
 void retro_deinit(void);
 
+// Must return RETRO_API_VERSION. Used to validate ABI compatibility when the API is revised.
 unsigned retro_api_version(void);
 
+// Gets statically known system info. Pointers provided in *info must be statically allocated.
+// Can be called at any time, even before retro_init().
 void retro_get_system_info(struct retro_system_info *info);
+
+// Gets information about system audio/video timings and geometry.
+// Can be called only after retro_load_game() has successfully completed.
+// NOTE: The implementation of this function might not initialize every variable if needed.
+// E.g. geom.aspect_ratio might not be initialized if core doesn't desire a particular aspect ratio.
 void retro_get_system_av_info(struct retro_system_av_info *info);
 
-void retro_set_environment(retro_environment_t);
-void retro_set_video_refresh(retro_video_refresh_t);
-void retro_set_audio_sample(retro_audio_sample_t);
-void retro_set_audio_sample_batch(retro_audio_sample_batch_t);
-void retro_set_input_poll(retro_input_poll_t);
-void retro_set_input_state(retro_input_state_t);
-
+// Sets device to be used for player 'port'.
 void retro_set_controller_port_device(unsigned port, unsigned device);
 
+// Resets the current game.
 void retro_reset(void);
+
+// Runs the game for one video frame.
+// During retro_run(), input_poll callback must be called at least once.
+//
+// If a frame is not rendered for reasons where a game "dropped" a frame,
+// this still counts as a frame, and retro_run() should explicitly dupe a frame if GET_CAN_DUPE returns true.
+// In this case, the video callback can take a NULL argument for data.
 void retro_run(void);
 
+// Returns the amount of data the implementation requires to serialize internal state (save states).
+// Beetween calls to retro_load_game() and retro_unload_game(), the returned size is never allowed to be larger than a previous returned value, to
+// ensure that the frontend can allocate a save state buffer once.
 size_t retro_serialize_size(void);
+
+// Serializes internal state. If failed, or size is lower than retro_serialize_size(), it should return false, true otherwise.
 bool retro_serialize(void *data, size_t size);
 bool retro_unserialize(const void *data, size_t size);
 
 void retro_cheat_reset(void);
 void retro_cheat_set(unsigned index, bool enabled, const char *code);
 
+// Loads a game.
 bool retro_load_game(const struct retro_game_info *game);
 
+// Loads a "special" kind of game. Should not be used except in extreme cases.
 bool retro_load_game_special(
   unsigned game_type,
   const struct retro_game_info *info, size_t num_info
 );
 
+// Unloads a currently loaded game.
 void retro_unload_game(void);
 
+// Gets region of game.
 unsigned retro_get_region(void);
 
+// Gets region of memory.
 void *retro_get_memory_data(unsigned id);
 size_t retro_get_memory_size(unsigned id);
 
Index: src/burner/libretro/neocdlist.cpp
===================================================================
--- src/burner/libretro/neocdlist.cpp	(revision 847)
+++ src/burner/libretro/neocdlist.cpp	(working copy)
@@ -2,7 +2,7 @@
 // NeoGeo CD Game Info Module (by CaptainCPS-X)
 // ---------------------------------------------------------------------------------------
 #include "burner.h"
-#include "neocdlist.h"
+#include "../neocdlist.h"
 
 struct NGCDGAME games[] = 
 {
Index: src/burner/libretro/tchar.h
===================================================================
--- src/burner/libretro/tchar.h	(revision 847)
+++ src/burner/libretro/tchar.h	(working copy)
@@ -67,5 +67,4 @@
 
 extern void InpDIPSWResetDIPs (void);
 
-
 #endif
Index: src/cpu/h6280_intf.cpp
===================================================================
--- src/cpu/h6280_intf.cpp	(revision 847)
+++ src/cpu/h6280_intf.cpp	(working copy)
@@ -1,5 +1,5 @@
 #include "burnint.h"
-#include "h6280.h"
+#include "h6280/h6280.h"
 #include "h6280_intf.h"
 
 #define MAX_H6280	2	//
Index: src/cpu/hd6309_intf.h
===================================================================
--- src/cpu/hd6309_intf.h	(revision 847)
+++ src/cpu/hd6309_intf.h	(working copy)
@@ -1,4 +1,4 @@
-#include "hd6309.h"
+#include "hd6309/hd6309.h"
 
 typedef UINT8 (*pReadByteHandler)(UINT16 a);
 typedef void (*pWriteByteHandler)(UINT16 a, UINT8 d);
Index: src/cpu/m6502_intf.h
===================================================================
--- src/cpu/m6502_intf.h	(revision 847)
+++ src/cpu/m6502_intf.h	(working copy)
@@ -1,4 +1,4 @@
-#include "m6502.h"
+#include "m6502/m6502.h"
 
 typedef UINT8 (*pReadPortHandler)(UINT16 a);
 typedef void (*pWritePortHandler)(UINT16 a, UINT8 d);
Index: src/cpu/m68000_intf.h
===================================================================
--- src/cpu/m68000_intf.h	(revision 847)
+++ src/cpu/m68000_intf.h	(working copy)
@@ -14,7 +14,7 @@
 #define SEK_MAX	(4)								// Maximum number of CPUs supported
 
 #if defined EMU_M68K
- #include "m68k.h"
+ #include "m68k/m68k.h"
 #endif
 
 // Number of bits used for each page in the fast memory map
Index: src/cpu/m6800_intf.h
===================================================================
--- src/cpu/m6800_intf.h	(revision 847)
+++ src/cpu/m6800_intf.h	(working copy)
@@ -1,4 +1,4 @@
-#include "m6800.h"
+#include "m6800/m6800.h"
 
 typedef UINT8 (*pReadByteHandler)(UINT16 a);
 typedef void (*pWriteByteHandler)(UINT16 a, UINT8 d);
Index: src/cpu/m6805_intf.h
===================================================================
--- src/cpu/m6805_intf.h	(revision 847)
+++ src/cpu/m6805_intf.h	(working copy)
@@ -1,4 +1,4 @@
-#include "m6805.h"
+#include "m6805/m6805.h"
 
 #define M6805_READ		1
 #define M6805_WRITE		2
Index: src/cpu/m6809_intf.h
===================================================================
--- src/cpu/m6809_intf.h	(revision 847)
+++ src/cpu/m6809_intf.h	(working copy)
@@ -1,4 +1,4 @@
-#include "m6809.h"
+#include "m6809/m6809.h"
 
 typedef UINT8 (*pReadByteHandler)(UINT16 a);
 typedef void (*pWriteByteHandler)(UINT16 a, UINT8 d);
Index: src/cpu/z80_intf.h
===================================================================
--- src/cpu/z80_intf.h	(revision 847)
+++ src/cpu/z80_intf.h	(working copy)
@@ -5,7 +5,7 @@
  #define __fastcall
 #endif
 
-#include "z80.h"
+#include "z80/z80.h"
 
 extern INT32 nHasZet;
 void ZetWriteByte(UINT16 address, UINT8 data);
